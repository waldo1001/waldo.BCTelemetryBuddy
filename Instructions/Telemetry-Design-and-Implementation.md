# Telemetry Design and Implementation for BCTelemetryBuddy

## Purpose and Scope

This document describes how to design and implement telemetry for the BCTelemetryBuddy **VS Code extension** and **MCP backend** using Azure Application Insights.

Goals:
- Track **which commands** are being used in the extension.
- Measure **how long Kusto (KQL) queries take** end‑to‑end.
- Track **which MCP tools** are used, how often, and how they perform.
- Capture **errors and failures** with enough context to debug, without collecting sensitive data.

All telemetry must respect user privacy, be configurable/disable‑able, and comply with VS Code marketplace and Azure policies.

---

## 1. Application Insights Setup

### 1.1 Create / Select Application Insights Resource

1. In Azure Portal, create (or reuse) an **Application Insights** resource.
2. Retrieve the **Connection String** (preferred) or **Instrumentation Key**.
3. Use a **single AI resource** for both Extension and MCP.
   - All telemetry from all users flows to this one resource.
   - Distinguish signals with a `component` property (`extension` vs. `mcp`).

### 1.2 Connection String Handling

**Fixed, Non-Configurable Connection String:**

- The Application Insights connection string is **hardcoded into shipped binaries** (VSIX for extension, npm package for MCP).
- It is **NOT** stored in the repository or user-configurable at runtime.
- Users cannot override or change where telemetry is sent.

**CI Build-Time Injection:**

1. Store the connection string as a **CI secret** (e.g., GitHub Actions secret, Azure DevOps variable).
2. During the build process, inject it into the code:
   - Create a generated file (e.g., `shared/src/telemetryConfig.generated.ts`):
     ```typescript
     // Auto-generated by CI - DO NOT COMMIT
     export const TELEMETRY_CONNECTION_STRING = process.env.AI_CONNECTION_STRING || '';
     ```
   - Add this file to `.gitignore` to prevent accidental commits.
   - CI workflow sets `AI_CONNECTION_STRING` environment variable before building.
3. Extension and MCP import this constant at initialization.

**Local Development:**

- For local dev/testing, use a separate dev AI resource.
- Create a local `.env` file (gitignored) with:
  ```
  AI_CONNECTION_STRING=InstrumentationKey=...;IngestionEndpoint=...
  ```
- The generated file reads from `process.env.AI_CONNECTION_STRING`.

**Security Trade-offs:**

- The connection string exists in compiled artifacts and could be extracted by determined users.
- This is generally acceptable for Application Insights (write-only ingestion endpoint).
- Treat it as sensitive; rotate if compromised.
- Given everyone runs locally with no shared identity, this is the only practical way to achieve "one shared connection string for all users."

**Security Safeguards (Required):**

To protect against abuse, quota exhaustion, and cost overruns, implement these safeguards:

1. **Azure Cost Budget Alerts**:
   - In Azure Portal → Cost Management → Budgets
   - Create budget for Application Insights resource
   - Set thresholds: 50%, 80%, 100%, 150% of expected monthly cost
   - Configure email alerts to project owner
   - Recommended starting budget: $50/month (adjust based on actual usage)

2. **Anomaly Detection Alerts**:
   - In Application Insights → Alerts → New alert rule
   - Create alerts for:
     - **Ingestion volume spike**: Alert if data ingestion exceeds 10x daily average
     - **Error rate spike**: Alert if exceptions exceed 100/hour
     - **Unique user spike**: Alert if unique `userId` count exceeds 2x expected
   - Actions: Email + SMS to project owner

3. **Client-Side Rate Limiting** (Implementation Required):
   - Prevent runaway telemetry in error loops
   - Limit identical errors to 10 per session
   - Limit total events to 1000 per session
   - See implementation in Section 6 below

4. **Connection String Rotation Procedure**:
   - If compromised, generate new connection string in Azure Portal
   - Update CI secret (`AI_CONNECTION_STRING`)
   - Trigger new build and release
   - Old connection string remains valid for 30 days (grace period for users to update)
   - After 30 days, disable old connection string in Azure
   - Document rotation in release notes

**Best-Effort Telemetry:**

- Telemetry must **never affect extension or MCP behavior**.
- If connection string is missing or invalid:
  - Use `NoOpUsageTelemetry` (silent no-op implementation).
  - No error messages, no command failures.
- All telemetry calls are fire-and-forget with try/catch wrappers.

### 1.3 Configuration Model

**What Users Can Configure:**

Users can control telemetry behavior via VS Code settings and `.bctb-config.json`, but **NOT** the connection string (which is fixed).

#### VS Code Extension Settings

The extension automatically respects VS Code's global telemetry setting (`vscode.env.isTelemetryEnabled`). No additional extension-specific setting is needed for enable/disable.

Optional setting in `package.json` for advanced users:
- `bcTelemetryBuddy.telemetry.environment` (string: "dev" | "test" | "prod") - for separating dev/prod telemetry

#### .bctb-config.json Structure

Add a **global `telemetry` section** to `.bctb-config.json` with optional per-profile overrides:

```json
{
  "telemetry": {
    "enabled": true,
    "environment": "prod",
    "samplingPercentage": 100
  },
  "profiles": {
    "production-customer": {
      "connectionName": "Acme Corp",
      "applicationInsightsAppId": "..."
    },
    "dev-testing": {
      "connectionName": "Dev Environment",
      "applicationInsightsAppId": "...",
      "telemetry": {
        "environment": "dev",
        "samplingPercentage": 10
      }
    }
  }
}
```

**Configuration hierarchy**:
1. Global `telemetry` block applies to all profiles
2. Per-profile `telemetry` overrides global settings
3. Extension reads config for enable/disable and sampling only
4. MCP reads same config when spawned by extension
5. Connection string is **NOT** in config - it's compiled into the binaries

**Environment variables (backward compatibility)**:
- `BC_TB_TELEMETRY_ENABLED` (true/false) - enable/disable only
- `BC_TB_TELEMETRY_ENVIRONMENT` (dev/test/prod) - environment tagging
- ~~`BC_TB_TELEMETRY_CONNECTION_STRING`~~ - **REMOVED** (use CI-injected constant instead)

---

## 2. Client-Side Rate Limiting

To prevent runaway telemetry costs from error loops or malicious usage, implement rate limiting on the client side.

### 2.1 Rate Limiting Strategy

**Goals**:
- Prevent identical errors from flooding Application Insights
- Limit total telemetry events per session
- Preserve critical error information (first occurrence always sent)
- Fail gracefully without affecting extension/MCP functionality

**Implementation**:

```typescript
interface RateLimitConfig {
  maxIdenticalErrors: number;      // Max same error per session (default: 10)
  maxEventsPerSession: number;     // Max total events per session (default: 1000)
  maxEventsPerMinute: number;      // Max events per minute (default: 100)
  errorCooldownMs: number;         // Cooldown after max errors (default: 60000)
}

class RateLimitedUsageTelemetry implements IUsageTelemetry {
  private innerTelemetry: IUsageTelemetry;
  private config: RateLimitConfig;
  
  // Tracking state
  private errorCounts = new Map<string, number>();
  private eventCount = 0;
  private minuteEventCounts: { timestamp: number; count: number }[] = [];
  private throttledErrors = new Set<string>();

  constructor(innerTelemetry: IUsageTelemetry, config?: Partial<RateLimitConfig>) {
    this.innerTelemetry = innerTelemetry;
    this.config = {
      maxIdenticalErrors: config?.maxIdenticalErrors ?? 10,
      maxEventsPerSession: config?.maxEventsPerSession ?? 1000,
      maxEventsPerMinute: config?.maxEventsPerMinute ?? 100,
      errorCooldownMs: config?.errorCooldownMs ?? 60000
    };
  }

  trackEvent(name: string, properties?: Record<string, any>, measurements?: Record<string, number>): void {
    if (!this.shouldTrack(name)) {
      return;
    }

    try {
      this.innerTelemetry.trackEvent(name, properties, measurements);
      this.incrementEventCount();
    } catch (error) {
      // Never fail - telemetry is best-effort
    }
  }

  trackException(error: Error, properties?: Record<string, string>): void {
    const errorKey = `${error.name}:${properties?.stackHash || ''}`;
    
    // Check if this error is throttled
    if (this.throttledErrors.has(errorKey)) {
      return;
    }

    const count = this.errorCounts.get(errorKey) || 0;
    
    if (count < this.config.maxIdenticalErrors) {
      try {
        this.innerTelemetry.trackException(error, {
          ...properties,
          errorOccurrence: (count + 1).toString(),
          isThrottled: 'false'
        });
        this.errorCounts.set(errorKey, count + 1);
        this.incrementEventCount();
      } catch (err) {
        // Never fail
      }
    } else if (count === this.config.maxIdenticalErrors) {
      // Send one final "throttled" event
      try {
        this.innerTelemetry.trackEvent('Telemetry.ErrorThrottled', {
          errorType: error.name,
          errorKey,
          occurrenceCount: count.toString(),
          message: `Error throttled after ${count} occurrences`
        });
        this.throttledErrors.add(errorKey);
        
        // Schedule cooldown removal
        setTimeout(() => {
          this.throttledErrors.delete(errorKey);
          this.errorCounts.delete(errorKey);
        }, this.config.errorCooldownMs);
      } catch (err) {
        // Never fail
      }
    }
  }

  trackDependency(name: string, data: string, durationMs: number, success: boolean, resultCode?: string, properties?: Record<string, string>): void {
    if (!this.shouldTrack('dependency')) {
      return;
    }

    try {
      this.innerTelemetry.trackDependency(name, data, durationMs, success, resultCode, properties);
      this.incrementEventCount();
    } catch (error) {
      // Never fail
    }
  }

  trackTrace(message: string, properties?: Record<string, string>): void {
    if (!this.shouldTrack('trace')) {
      return;
    }

    try {
      this.innerTelemetry.trackTrace(message, properties);
      this.incrementEventCount();
    } catch (error) {
      // Never fail
    }
  }

  async flush(): Promise<void> {
    try {
      await this.innerTelemetry.flush();
    } catch (error) {
      // Never fail
    }
  }

  private shouldTrack(eventType: string): boolean {
    // Check session limit
    if (this.eventCount >= this.config.maxEventsPerSession) {
      return false;
    }

    // Check per-minute limit
    const now = Date.now();
    const oneMinuteAgo = now - 60000;
    
    // Clean old entries
    this.minuteEventCounts = this.minuteEventCounts.filter(e => e.timestamp > oneMinuteAgo);
    
    // Count events in last minute
    const recentCount = this.minuteEventCounts.reduce((sum, e) => sum + e.count, 0);
    
    if (recentCount >= this.config.maxEventsPerMinute) {
      return false;
    }

    return true;
  }

  private incrementEventCount(): void {
    this.eventCount++;
    
    const now = Date.now();
    const currentMinute = Math.floor(now / 60000) * 60000;
    
    const existing = this.minuteEventCounts.find(e => e.timestamp === currentMinute);
    if (existing) {
      existing.count++;
    } else {
      this.minuteEventCounts.push({ timestamp: currentMinute, count: 1 });
    }
  }
}
```

### 2.2 Usage in Extension and MCP

**Extension (packages/extension/src/extension.ts)**:
```typescript
let usageTelemetry: IUsageTelemetry;

export function activate(context: vscode.ExtensionContext) {
  try {
    const connectionString = TELEMETRY_CONNECTION_STRING;
    
    if (!connectionString || !vscode.env.isTelemetryEnabled) {
      usageTelemetry = new NoOpUsageTelemetry();
    } else {
      const reporter = new TelemetryReporter(connectionString);
      const baseTelemetry = new VSCodeUsageTelemetry(reporter);
      
      // Wrap with rate limiting
      usageTelemetry = new RateLimitedUsageTelemetry(baseTelemetry, {
        maxIdenticalErrors: 10,
        maxEventsPerSession: 1000,
        maxEventsPerMinute: 100
      });
    }
  } catch (error) {
    // Fall back to no-op if initialization fails
    usageTelemetry = new NoOpUsageTelemetry();
  }
}
```

**MCP Backend (packages/mcp/src/server.ts)**:
```typescript
let usageTelemetry: IUsageTelemetry;

function initializeTelemetry(config: Config) {
  try {
    const connectionString = TELEMETRY_CONNECTION_STRING;
    
    if (!connectionString || !config.telemetry?.enabled) {
      usageTelemetry = new NoOpUsageTelemetry();
    } else {
      appInsights.setup(connectionString)
        .setAutoCollectRequests(true)
        .setAutoCollectDependencies(true)
        .start();
      
      const baseTelemetry = new AppInsightsUsageTelemetry(appInsights.defaultClient);
      
      // Wrap with rate limiting
      usageTelemetry = new RateLimitedUsageTelemetry(baseTelemetry, {
        maxIdenticalErrors: 10,
        maxEventsPerSession: 2000,  // Higher limit for MCP (more events)
        maxEventsPerMinute: 200
      });
    }
  } catch (error) {
    usageTelemetry = new NoOpUsageTelemetry();
  }
}
```

### 2.3 Monitoring Rate Limiting

Track when rate limiting is triggered:

```kusto
// Find sessions hitting rate limits
customEvents
| where name == "Telemetry.ErrorThrottled"
| summarize 
    throttledErrors = count(),
    uniqueErrors = dcount(tostring(customDimensions.errorType))
  by sessionId = tostring(customDimensions.sessionId)
| where throttledErrors > 5
| order by throttledErrors desc
```

This helps identify problematic users or bugs causing excessive telemetry.

---

## 3. Usage Telemetry Abstraction

To keep the implementation clean and testable, introduce an explicit usage telemetry abstraction that can be used by both Extension and MCP.

**⚠️ IMPORTANT NAMING**: The project already has a `TelemetryService` class in `packages/extension/src/services/telemetryService.ts` that is used for **querying Business Central telemetry** (executing KQL against Application Insights). The new telemetry for **tracking usage** of the extension/MCP uses the **"UsageTelemetry"** prefix to avoid confusion.

**Naming Convention**:
- **UsageTelemetry** prefix: For tracking extension/MCP usage (new feature)
- **TelemetryService**: Existing service for querying BC telemetry (keep as-is, no changes)

### 3.1 Usage Telemetry Interface (shared)

Create a TypeScript interface in `shared/src/usageTelemetry.ts`:

```typescript
export interface IUsageTelemetry {
    trackEvent(name: string, properties?: Record<string, string | number | boolean>, measurements?: Record<string, number>): void;
    trackDependency(name: string, data: string, durationMs: number, success: boolean, resultCode?: string, properties?: Record<string, string>): void;
    trackException(error: Error, properties?: Record<string, string>): void;
    trackTrace(message: string, properties?: Record<string, string>): void;
    flush(): Promise<void>;
}
```

Concrete implementations:
- **AppInsightsUsageTelemetry**: Sends data to Application Insights (for MCP backend).
- **VSCodeUsageTelemetry**: Uses `@vscode/extension-telemetry` TelemetryReporter (for extension).
- **NoOpUsageTelemetry**: Used when telemetry is disabled or configuration is missing.
- **RateLimitedUsageTelemetry**: Wraps any implementation with rate limiting (Section 2).
- **TelemetryLevelFilter**: Filters events based on VS Code telemetry level (extension only).

### 3.2 Telemetry Level Filter (VS Code Extension Only)

**Purpose**: Respect VS Code's granular telemetry levels.

```typescript
/**
 * Filters usage telemetry events based on VS Code telemetry level
 */
class TelemetryLevelFilter implements IUsageTelemetry {
  private innerTelemetry: IUsageTelemetry;
  private level: 'off' | 'crash' | 'error' | 'all';

  constructor(innerTelemetry: IUsageTelemetry, level: 'off' | 'crash' | 'error' | 'all') {
    this.innerTelemetry = innerTelemetry;
    this.level = level;
  }

  trackEvent(name: string, properties?: Record<string, any>, measurements?: Record<string, number>): void {
    // Level 'off' - nothing gets through (handled by NoOp)
    // Level 'crash' - extensions don't handle crashes, so nothing
    // Level 'error' - only error/exception events
    // Level 'all' - everything
    
    if (this.level === 'all') {
      this.innerTelemetry.trackEvent(name, properties, measurements);
      return;
    }
    
    if (this.level === 'error' && (name.includes('Error') || name.includes('Failed'))) {
      this.innerTelemetry.trackEvent(name, properties, measurements);
      return;
    }
    
    // For 'crash' or 'error' with non-error events, do nothing
  }

  trackException(error: Error, properties?: Record<string, string>): void {
    // Exceptions are tracked at 'error' and 'all' levels
    if (this.level === 'error' || this.level === 'all') {
      this.innerTelemetry.trackException(error, properties);
    }
  }

  trackDependency(name: string, data: string, durationMs: number, success: boolean, resultCode?: string, properties?: Record<string, string>): void {
    // Dependencies are only tracked at 'all' level
    if (this.level === 'all') {
      this.innerTelemetry.trackDependency(name, data, durationMs, success, resultCode, properties);
    }
  }

  trackTrace(message: string, properties?: Record<string, string>): void {
    // Traces are only tracked at 'all' level
    if (this.level === 'all') {
      this.innerTelemetry.trackTrace(message, properties);
    }
  }

  async flush(): Promise<void> {
    await this.innerTelemetry.flush();
  }
}
```

**Behavior by level**:
- `off`: No telemetry (use `NoOpUsageTelemetry` instead)
- `crash`: No telemetry (extensions can't report crashes separately)
- `error`: Only `trackException()` and error-related events
- `all`: Full telemetry (default)

### 3.3 Extension vs MCP Implementation

**Extension (VS Code)**:
- Use **`@vscode/extension-telemetry`** package (official VS Code telemetry API)
- Must respect user's **granular telemetry level** (`telemetry.telemetryLevel` setting)
- Requires `TelemetryReporter` initialized with your AI instrumentation key
- Aligns with VS Code marketplace guidelines

**VS Code Telemetry Levels** (handle all four):
- `off` - No telemetry at all (use `NoOpUsageTelemetry`)
- `crash` - Only unhandled crashes (not applicable to extensions)
- `error` - Crashes + errors (track exceptions only)
- `all` - Full telemetry (track everything)

```typescript
import TelemetryReporter from '@vscode/extension-telemetry';
import * as vscode from 'vscode';

function getTelemetryLevel(): 'off' | 'crash' | 'error' | 'all' {
  const config = vscode.workspace.getConfiguration('telemetry');
  const level = config.get<string>('telemetryLevel', 'all');
  
  // Legacy support for isTelemetryEnabled (deprecated but still used)
  if (!vscode.env.isTelemetryEnabled) {
    return 'off';
  }
  
  return level as 'off' | 'crash' | 'error' | 'all';
}

function createUsageTelemetry(connectionString: string, context: vscode.ExtensionContext): IUsageTelemetry {
  const level = getTelemetryLevel();
  
  if (level === 'off') {
    return new NoOpUsageTelemetry();
  }
  
  const reporter = new TelemetryReporter(connectionString);
  const baseTelemetry = new VSCodeUsageTelemetry(reporter);
  const rateLimited = new RateLimitedUsageTelemetry(baseTelemetry);
  
  // Wrap with level filter
  return new TelemetryLevelFilter(rateLimited, level);
}
```

**MCP Backend (Node.js)**:
- Use **`applicationinsights`** SDK directly
- Manual configuration of telemetry enabled/disabled via config
- Express middleware for automatic request tracking

```typescript
import * as appInsights from 'applicationinsights';

appInsights.setup('your-connection-string')
    .setAutoCollectRequests(true)
    .setAutoCollectDependencies(true)
    .start();
```

### 3.4 Initialization Pattern

- Initialize usage telemetry **once per process**:
  - **Extension**: in `activate` (in `packages/extension/src/extension.ts`).
    - Check `telemetry.telemetryLevel` setting (VS Code marketplace requirement)
    - Support legacy `vscode.env.isTelemetryEnabled` for backward compatibility
    - Import `TELEMETRY_CONNECTION_STRING` from the CI-generated file
    - If connection string is empty/missing OR level is 'off' → use `NoOpUsageTelemetry`
    - Otherwise, create telemetry stack:
      1. `TelemetryReporter` (base)
      2. `VSCodeUsageTelemetry` (wrapper)
      3. `RateLimitedUsageTelemetry` (rate limiting)
      4. `TelemetryLevelFilter` (respect VS Code level)
    - Wrap initialization in try/catch; on error → fall back to `NoOpUsageTelemetry`
  - **MCP**: in `server` startup (in `packages/mcp/src/server.ts`).
    - Check config `telemetry.enabled` flag
    - Import `TELEMETRY_CONNECTION_STRING` from the CI-generated file
    - If disabled or connection string missing → use `NoOpUsageTelemetry`
    - Otherwise, initialize `applicationinsights` SDK with connection string
    - Wrap initialization in try/catch; on error → fall back to `NoOpUsageTelemetry`
- Inject or export the `IUsageTelemetry` instance for other modules to use.
- **CRITICAL: Usage telemetry must never affect behavior**:
  - All `trackEvent/trackDependency/trackException` calls must be fire-and-forget
  - Wrap all usage telemetry calls in try/catch and swallow exceptions silently
  - No user-facing error messages or command failures when usage telemetry fails
- **Add to package dependencies**:
  - Extension: `npm install @vscode/extension-telemetry`
  - MCP: `npm install applicationinsights`

---

## 4. Extension Usage Telemetry (VS Code)

### 4.1 Command Usage Tracking

For every command contributed by the extension (registered in `extension.ts`):

1. Wrap the command handler in a helper like `runWithUsageTelemetry(commandName, handler)`.
2. On invocation:
   - Record `startTime = Date.now()`.
   - Optionally send `Extension.CommandInvoked` with properties:
     - `commandName`
     - `source = "extension"`
     - `version` (extension version)
     - `profileIdHash`, `chatMode`, etc. (if applicable and non‑sensitive).
3. On completion:
   - Compute `durationMs = Date.now() - startTime`.
   - Send `Extension.CommandCompleted` with:
     - `commandName`
     - `success` (true/false)
     - `errorType` (if failed, e.g. `ValidationError`, `McpError`)
     - `errorMessageShort` (short, non‑PII description)
   - Add `durationMs` as a measurement.

This yields:
- **What commands are used** (by counting `Extension.CommandCompleted` by `commandName`).
- **How long they take** (using the `durationMs` measurement).

### 4.2 Extension Error Tracking

Whenever a command or background operation throws:

- Catch the error at the highest sensible layer.
- Call `usageTelemetry.trackException(error, { component: "extension", commandName, operation })`.
- Do not log sensitive details (no raw queries, no file contents, no tokens).

Optionally, add a tiny wrapper for command registration that always applies try/catch and usage telemetry.

---

## 5. MCP Usage Telemetry

### 5.1 MCP Tool Usage & Request Correlation

Each MCP tool (method exposed by the MCP server) should send telemetry on invocation and completion.

**Request Correlation Pattern**:

The extension should pass a `correlationId` to the MCP server for end-to-end tracing:

```typescript
// Extension (mcpClient.ts)
const correlationId = generateGuid();
const response = await mcpClient.request('query_telemetry', {
  kql: '...',
  _correlationId: correlationId  // Pass to MCP
});

usageTelemetry.trackEvent('Extension.McpRequestSent', {
  correlationId,
  method: 'query_telemetry'
});
```

```typescript
// MCP Server (server.ts)
app.post('/jsonrpc', async (req, res) => {
  const correlationId = req.body.params?._correlationId || generateGuid();
  const requestId = generateGuid(); // MCP-specific ID
  
  usageTelemetry.trackEvent('Mcp.RequestReceived', {
    correlationId,  // Links to extension
    requestId,      // MCP-specific
    method: req.body.method
  });
});
```

**Pattern per tool handler**:

1. **On entry**:
   - Extract `correlationId` from request params (or generate if missing)
   - Generate a `requestId` (GUID, MCP-specific)
   - Record `startTime`

2. **On completion (success or failure)**:
   - Compute `durationMs`
   - Send tool-specific event (e.g., `Mcp.QueryTelemetry`, `Mcp.GetSavedQueries`) with properties:
     - `eventId` (tool-specific, e.g., `TB-MCP-101`, `TB-MCP-102`)
     - `requestId`
     - `correlationId`
     - `success` (true/false)
     - `errorType` (if failed)
     - `caller` (if known, e.g. `extension`, `cli`)
     - `component = "mcp"`
     - Domain-specific context, e.g. `queryName`, `cacheHit`, etc.
   - Add `durationMs` as a measurement
   - If failed, also send `trackException` with full error context

**Benefits**:
- **End-to-end tracing**: Link extension command → MCP tool → Kusto query
- **Which MCP tools are used** and how often
- **How long they take** and how often they fail
- **Distributed debugging**: Find all related events by `correlationId`

### 5.2 Kusto (KQL) Performance

Wherever Kusto is called (likely in `shared/src/kusto.ts` or MCP‑specific query module):

**Use `trackDependency` for external calls** (recommended approach for Application Insights):

1. Wrap the Kusto client call in telemetry logic
2. On entry:
   - Record `startTime`
3. On completion:
   - Compute `durationMs`
   - Use `trackDependency` for automatic correlation and Application Map visualization:

```typescript
const startTime = Date.now();
try {
  const result = await kustoClient.execute(kql, token);
  const durationMs = Date.now() - startTime;
  
  usageTelemetry.trackDependency(
    'Kusto',                    // dependencyTypeName
    'AppInsights',              // name (generic, no cluster/database info)
    durationMs,                 // duration
    true,                       // success
    '200',                      // resultCode
    {
      queryName: 'SlowQueries',  // Logical name, NOT raw KQL
      correlationId,
      cacheHit: 'false',
      component: 'shared',
      rowCount: result.rows.length.toString()
    }
  );
} catch (error) {
  const durationMs = Date.now() - startTime;
  
  // CRITICAL: Only track repo-internal errors, sanitize external errors
  const sanitizedError = sanitizeExternalError(error);
  
  usageTelemetry.trackDependency('Kusto', 'AppInsights', durationMs, false, '500', {
    queryName: 'SlowQueries',
    correlationId,
    errorType: sanitizedError.type,
    errorCategory: sanitizedError.category  // 'KustoError', 'NetworkError', etc.
  });
  throw error;
}
```

**Properties to include**:
- `queryName` (logical identifier, e.g., "ErrorsByDay", "SlowQueries")
- `cacheHit` (boolean)
- `correlationId` (for request tracing)
- `component = "mcp"` or `"shared"`
- `rowCount` (aggregated count, not actual data)

**❌ REMOVED FOR PRIVACY**:
- ~~`clusterHash`, `databaseHash`~~ - Even hashed, these can fingerprint customer environments

**⚠️ CRITICAL: NEVER include**:
- **KQL query text** - ANY raw query text is considered sensitive data (may contain secrets, customer-specific table names, business logic, filters with PII)
- Query results or actual row data
- User principal names, email addresses, or tenant names
- Connection strings or tokens

**How to derive `queryName` safely**:
- Use saved query names from your query library (e.g., "ErrorsByDay", "TopErrorMessages")
- For chat-generated queries: use descriptive labels like "ChatGenerated_Performance"
- For ad-hoc queries: use generic label "AdHocQuery"
- For tool-specific queries: use pattern "ToolName_QueryPurpose" (e.g., "GetRecommendations_QueryData")
- **NEVER** derive queryName from actual KQL text, table names, or customer-specific identifiers

**Benefits of `trackDependency`**:
- Automatic **Application Map** visualization showing Extension → MCP → Kusto flow
- Built-in correlation with requests
- Standard dependency metrics (duration, success rate, failures)

This yields:
- **How long KQL takes** (overall and per logical query)
- Insight into slow or failing queries
- Visual dependency graph in Application Insights

### 5.3 MCP Error Tracking

On unhandled exceptions or explicit error paths in the MCP:

- Call `usageTelemetry.trackException(error, { component: "mcp", operation, toolName, queryName })`.
- Optionally send a separate `Mcp.Error` event with a small, structured payload.

---

## 6. Event Naming and Data Model

### 6.1 Event Names

Use consistent, hierarchical names for events:

- **Extension events**:
  - `Extension.CommandInvoked`
  - `Extension.CommandCompleted`
  - `Extension.Error`

- **MCP events** (per tool):
  - `Mcp.QueryTelemetry`
  - `Mcp.GetSavedQueries`
  - `Mcp.SearchQueries`
  - `Mcp.SaveQuery`
  - `Mcp.GenerateKQL`
  - `Mcp.GetRecommendations`
  - `Mcp.LookupEvent`
  - `Mcp.Error`

- **Kusto performance**:
  - `Kusto.QueryExecuted`
  - `Kusto.QueryFailed` (or rely on `exceptions` / dependency failures).

### 6.2 Common Properties

Define a small core set of shared dimensions applied to most events:

- `component`: `extension` | `mcp` | `shared`.
- `environment`: `dev` | `test` | `prod` (from config).
- `version`: extension or MCP version.
- `sessionId`: random GUID per process start.
- `installationId`: random identifier (changes on reinstall, NOT tied to user/machine).
- `os`, `nodeVersion`, `vscodeVersion` (where known and useful).

Domain‑specific properties:

- **Commands**:
  - `commandName`, `profileIdHash`, `chatMode`, `source`.

- **MCP tools**:
  - `toolName`, `requestId`, `caller`, `queryName`.

- **Kusto**:
  - `queryName`, `cacheHit` (NO cluster/database identifiers).

- **Errors**:
  - `errorType` (sanitized), `errorCategory`, `stackHash` (repo-only frames), `operation`, `toolName` / `commandName`.

Measurements (numeric):
- `durationMs` for commands, tools, and queries.
- Optionally `resultRowCount`, `resultSizeKb` (aggregated, non‑sensitive).

---

## 8. Cost Control and Sampling

### 8.1 Application Insights Costs

Application Insights pricing is based on **data volume ingested** (per GB). High-frequency events can become expensive.

**Cost estimates**:
- Typical event: ~1-2 KB
- 1000 events = ~1-2 MB
- 1M events = ~1-2 GB (~$2-3/month at current Azure pricing)
- Active users generating 100+ events/day can add up quickly

### 8.2 Sampling Strategies

**Adaptive Sampling (Built-in)**:
- Application Insights SDK includes adaptive sampling by default
- Automatically reduces volume when ingestion is high
- Keeps 100% of errors and exceptions
- Recommended: Enable by default, set max rate

```typescript
// MCP backend
appInsights.setup(connectionString)
  .setAutoCollectRequests(true)
  .setAutoCollectDependencies(true)
  .setSendLiveMetrics(false)  // Disable live metrics to save cost
  .start();

// Set sampling percentage
appInsights.defaultClient.config.samplingPercentage = 100; // Start at 100%, adjust if needed
```

**Custom Sampling (Per Event Type)**:

Implement selective sampling based on event importance:

```typescript
class SampledUsageTelemetry implements IUsageTelemetry {
  trackEvent(name: string, properties?: Record<string, any>, measurements?: Record<string, number>) {
    // Always track errors and important events
    if (name.includes('Error') || name.includes('Exception') || properties?.success === false) {
      this.innerTelemetry.trackEvent(name, properties, measurements);
      return;
    }
    
    // Sample successful queries at 10%
    if (name === 'Kusto.QueryExecuted' && Math.random() < 0.1) {
      this.innerTelemetry.trackEvent(name, properties, measurements);
    }
    
    // Always track command invocations (lower volume)
    if (name.includes('Command')) {
      this.innerTelemetry.trackEvent(name, properties, measurements);
    }
  }
}
```

**Recommended sampling rates**:
- **Errors/Exceptions**: 100% (always)
- **Command invocations**: 100% (low volume)
- **MCP tool calls**: 100% (medium volume)
- **Successful Kusto queries**: 10-25% (high volume)
- **Cache hits**: 5% (very high volume, less important)

### 8.3 Configuration

Add `samplingPercentage` to `.bctb-config.json`:

```json
{
  "telemetry": {
    "enabled": true,
    "samplingPercentage": 100,
    "samplingRules": {
      "Kusto.QueryExecuted": 10,
      "Mcp.QueryTelemetry": 100,
      "Mcp.GetSavedQueries": 100,
      "Extension.CommandCompleted": 100
    }
  }
}
```

## 9. Session and User Identification

### 9.1 Session ID

Generate once per process and include in all events:

**Extension**:
```typescript
const sessionId = generateGuid(); // In activate()
// Include in all usage telemetry events
usageTelemetry.trackEvent('Extension.CommandInvoked', {
  sessionId,
  commandName: 'runQuery'
});
```

**MCP Backend**:
```typescript
const sessionId = generateGuid(); // At server startup
// Include in all usage telemetry events
usageTelemetry.trackEvent('Mcp.QueryTelemetry', {
  eventId: 'TB-MCP-101',
  sessionId,
  success: 'true'
});
```

### 9.2 Installation Identification (Privacy-First)

**PRIVACY PRINCIPLE**: Track installations pseudonymously for debugging, allow users to reset their ID.

**Design Goals**:
- ✅ Unique per installation (analyze patterns: "does error X only affect user Y?")
- ✅ Persistent across sessions (track behavior over time)
- ✅ User-resettable (GDPR compliance: user can "start fresh")
- ✅ Not tied to personal identifiers (no machineId, username, workspace path)
- ✅ Transparent (user can see/reset their ID via command)

**Extension**: Generate random installation ID stored in extension global state:
```typescript
import * as vscode from 'vscode';
import * as crypto from 'crypto';

function getInstallationId(context: vscode.ExtensionContext): string {
  const key = 'bcTelemetryBuddy.installationId';
  let installationId = context.globalState.get<string>(key);
  
  if (!installationId) {
    // Generate new random installation ID
    installationId = crypto.randomBytes(16).toString('hex');
    context.globalState.update(key, installationId);
  }
  
  return installationId;
}

// Allow users to reset their installation ID (GDPR "right to start fresh")
function resetInstallationId(context: vscode.ExtensionContext): string {
  const key = 'bcTelemetryBuddy.installationId';
  const newId = crypto.randomBytes(16).toString('hex');
  context.globalState.update(key, newId);
  return newId;
}

// Register command for users to reset ID
vscode.commands.registerCommand('bcTelemetryBuddy.resetTelemetryId', async () => {
  const newId = resetInstallationId(context);
  vscode.window.showInformationMessage(
    `Telemetry ID reset. Your new anonymous ID: ${newId.substring(0, 8)}...`
  );
});

// Include in usage telemetry
usageTelemetry.trackEvent('Extension.CommandInvoked', {
  installationId,  // Random but persistent, user can reset anytime
  sessionId
});
```

**MCP Backend**: Generate random installation ID per workspace:
```typescript
import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';

function getInstallationId(workspacePath: string): string {
  const idFile = path.join(workspacePath, '.bctb-installation-id');
  
  if (fs.existsSync(idFile)) {
    return fs.readFileSync(idFile, 'utf-8').trim();
  }
  
  // Generate new random installation ID
  const installationId = crypto.randomBytes(16).toString('hex');
  fs.writeFileSync(idFile, installationId);
  
  // Add to .gitignore if not already there
  addToGitignore(workspacePath, '.bctb-installation-id');
  
  return installationId;
}

// Allow users to reset by deleting the file
function resetInstallationId(workspacePath: string): string {
  const idFile = path.join(workspacePath, '.bctb-installation-id');
  if (fs.existsSync(idFile)) {
    fs.unlinkSync(idFile);
  }
  return getInstallationId(workspacePath); // Generates new one
}
```

**CRITICAL GDPR Compliance**:
- Installation ID is **pseudonymous** - random, not derived from user data
- Installation ID is **persistent** - same ID across sessions for pattern analysis
- Installation ID is **resettable** - user can reset via command or deleting file
- Installation ID is **transparent** - user can see it via command
- No link to real identity without user's cooperation

**User Control**:
1. **Extension**: `Ctrl+Shift+P` → "BC Telemetry Buddy: Reset Telemetry ID"
2. **MCP**: Delete `.bctb-installation-id` file in workspace root
3. **Document in UserGuide**: How to reset, why it exists, what it's used for

**What This Enables**:
```kusto
// Find errors that only affect one installation
customEvents
| where name == "Extension.Error"
| summarize 
    installations = dcount(tostring(customDimensions.installationId)),
    occurrences = count()
  by errorType = tostring(customDimensions.errorType)
| where installations == 1 and occurrences > 5
// Shows errors that repeatedly affect the same installation
```

**GDPR Justification**:
- **Legitimate Interest**: Debugging and improving software quality
- **Minimal Data**: Only a random ID, no personal information
- **User Control**: Can reset ID anytime, can disable telemetry entirely
- **Transparency**: Documented in privacy policy, visible via command
- **No Profiling**: Used only for error correlation, not behavioral tracking

### 9.3 Profile Correlation

Track which profile is being used (without exposing customer names):

```typescript
const profileHash = crypto.createHash('sha256')
  .update(profileName)
  .digest('hex')
  .substring(0, 12);

usageTelemetry.trackEvent('Mcp.QueryTelemetry', {
  eventId: 'TB-MCP-101',
  profileHash,  // E.g., "a1b2c3d4e5f6" instead of "Acme Corp"
  sessionId,
  installationId,  // Random, not tied to user
  success: 'true'
});
```

## 10. Privacy, Opt‑In, and Documentation

### 10.1 GDPR Compliance Summary

**Privacy-First Approach**: This telemetry design prioritizes user privacy and GDPR compliance:

1. **Pseudonymous Installation Tracking**:
   - ✅ Random installation IDs (not derived from user data)
   - ✅ Persistent across sessions (enables error pattern analysis)
   - ✅ User-resettable anytime (via command or file deletion)
   - ✅ Transparent (user can view/reset their ID)
   - ❌ No link to personal identifiers (machine, email, username)
   - **GDPR Basis**: Legitimate interest (software quality), minimal data, user control

2. **No Personal Data in Errors**:
   - ❌ No file paths containing usernames
   - ❌ No email addresses, tenant IDs, or customer identifiers
   - ❌ No database/cluster information (even hashed)
   - ✅ Only repo-internal stack traces (external errors categorized generically)

2. **No Personal Data in Errors**:
   - ❌ No file paths containing usernames
   - ❌ No email addresses, tenant IDs, or customer identifiers
   - ❌ No database/cluster information (even hashed)
   - ✅ Only repo-internal stack traces (external errors categorized generically)

3. **Repo-Internal Errors Only**:
   - ✅ Track only errors originating from BCTelemetryBuddy code
   - ❌ External errors (Kusto, Azure, npm) are categorized generically
   - ✅ Stack traces limited to repo frames only
   - ❌ No detailed Kusto error messages (may contain customer data)

4. **Data Retention**: 
   - Default: 90 days in Azure Application Insights
   - Configurable via Azure Portal (can be reduced to 30 days)
   - No long-term archival

5. **"Right to Start Fresh"**:
   - User can reset installation ID anytime
   - Extension: Command `BC Telemetry Buddy: Reset Telemetry ID`
   - MCP: Delete `.bctb-installation-id` file
   - New ID generated → past telemetry cannot be linked to new sessions
   - Equivalent to "right to be forgotten" for pseudonymous data

6. **Opt-Out Mechanism**:
   - VS Code global telemetry setting (extension)
   - `.bctb-config.json` or environment variable (MCP)
   - Telemetry disabled by default if setting not found

7. **Geographic Data Residency**:
   - Recommended: Use EU Azure region for EU users' data sovereignty
   - Alternative: US region (acceptable for pseudonymous data)

### 10.2 Opt‑In / Opt‑Out

**Extension (VS Code)**:
- **Must respect `telemetry.telemetryLevel` setting** (VS Code marketplace requirement):
  - `off` - No telemetry
  - `crash` - No telemetry (extensions don't report crashes separately)
  - `error` - Only exceptions and error events
  - `all` - Full telemetry (default)
- Also respect legacy `vscode.env.isTelemetryEnabled` for backward compatibility
- No separate extension-specific setting needed (use VS Code global setting)

**MCP Backend**:
- Controlled via `.bctb-config.json`:
  - `telemetry.enabled = false` fully disables telemetry
- Environment variable as fallback:
  - `BC_TB_TELEMETRY_ENABLED=false`
- Default: Enabled if no setting found

### 10.2 Data Minimization

- Do **not** send:
  - **KQL query text** - treat ALL raw query text as sensitive (may contain secrets, customer-specific logic, table names with business context, filters with PII).
  - Kusto results or actual business data.
  - Usernames, email addresses, tenant names, or tokens.
  - Customer-specific table names, column names, or database schema information.
- Prefer short identifiers or hashes (e.g. `profileIdHash`) for correlation.
- Use logical, predefined names for `queryName` (never derived from actual KQL text).

### 10.4 User‑Facing Documentation

Update `docs/UserGuide.md` with a **Telemetry & Privacy** section that explains:

- What is collected (high‑level usage, performance, repo-internal errors only).
- What is **NOT** collected:
  - ❌ No KQL query text or results
  - ❌ No file paths, usernames, or PII
  - ❌ No customer/tenant identifiers
  - ❌ No database/cluster information
  - ❌ External error details (Kusto errors, Azure errors)
  - ✅ Only errors from BCTelemetryBuddy code itself
- How to enable/disable telemetry:
  - **Extension**: VS Code setting `telemetry.telemetryLevel`
    - `File` → `Preferences` → `Settings` → Search "telemetry"
    - Options: `off` (disabled), `error` (errors only), `all` (full telemetry)
  - **MCP**: `.bctb-config.json` → `telemetry.enabled: false`
  - **MCP**: Environment variable `BC_TB_TELEMETRY_ENABLED=false`
- Where telemetry is sent (Azure Application Insights, project-owned).
- Privacy approach:
  - Random installation IDs (not tied to users or machines)
  - **Persistent across sessions** for debugging (analyze patterns per installation)
  - **User can reset ID anytime**:
    - Extension: `Ctrl+Shift+P` → "BC Telemetry Buddy: Reset Telemetry ID"
    - MCP: Delete `.bctb-installation-id` file in workspace
  - Profile names hashed (customer names not exposed)
  - Only repo-internal stack traces tracked
- Sampling strategy (not all events are sent, errors always captured).
- Data retention: 90 days (configurable in Azure).
- **Why we track installation IDs**:
  - Enables debugging: "Does error X only affect installation Y?"
  - No personal data: Random ID, no link to identity
  - Full user control: Reset anytime to "start fresh"

---

## 11. Enhanced Error Context

### 11.1 Stack Traces - Repo-Only Frames

**PRIVACY PRINCIPLE**: Only track stack frames from this repository. External errors (Kusto, Azure, npm packages) are sanitized.

```typescript
/**
 * Sanitize stack trace to only include frames from this repo
 * Removes: file paths with usernames, external package frames, system paths
 */
function sanitizeStackTrace(stack: string | undefined, repoRoot: string): string {
  if (!stack) return '';
  
  const lines = stack.split('\n');
  const repoFrames: string[] = [];
  
  for (const line of lines) {
    // Only include frames from our repo
    if (line.includes(repoRoot)) {
      // Remove full path, keep only relative path from repo root
      const relativePath = line.substring(line.indexOf(repoRoot) + repoRoot.length)
        .replace(/\\/g, '/')
        .replace(/^[\/]+/, '');
      
      // Extract just the file and function (no line numbers, no full paths)
      const sanitized = relativePath
        .replace(/:\d+:\d+/g, '')  // Remove line:column
        .replace(/\s+at\s+/g, 'at ');  // Normalize spacing
      
      repoFrames.push(sanitized);
    }
  }
  
  // Return only top 5 repo frames
  return repoFrames.slice(0, 5).join('\n');
}

function hashStackTrace(stack: string): string {
  if (!stack) return 'no-stack';
  return crypto.createHash('sha256').update(stack).digest('hex').substring(0, 12);
}

function trackExceptionSafe(error: Error, properties?: Record<string, string>, repoRoot: string) {
  // Sanitize stack to repo-only frames
  const sanitizedStack = sanitizeStackTrace(error.stack, repoRoot);
  const stackHash = hashStackTrace(sanitizedStack);
  
  // Sanitize error message (remove external error details)
  const sanitizedMessage = sanitizeErrorMessage(error.message);
  
  // Categorize error source
  const errorCategory = categorizeError(error, sanitizedStack);
  
  usageTelemetry.trackException(error, {
    ...properties,
    stackHash,
    errorMessage: sanitizedMessage.substring(0, 200),
    errorType: error.name,
    errorCategory,  // 'RepoInternal', 'ExternalAPI', 'Network', etc.
    hasRepoFrames: (sanitizedStack.length > 0).toString()
  });
}
```

**Benefits**:
- Zero PII (no file paths with usernames)
- Only track errors originating from our code
- External API errors (Kusto, Azure) are categorized but not detailed

### 11.2 Error Message Sanitization

**PRIVACY PRINCIPLE**: Only track error messages from repo code. External errors are categorized generically.

```typescript
/**
 * Sanitize error message to remove PII and external service details
 */
function sanitizeErrorMessage(message: string): string {
  if (!message) return 'No error message';
  
  // Block common PII patterns
  let sanitized = message
    // Remove file paths
    .replace(/[A-Za-z]:\\[^\s"']+/g, '[path]')
    .replace(/\/[^\s"']+\/(Users|home)\/[^\s"'\/]+/g, '[path]')
    // Remove email addresses
    .replace(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g, '[email]')
    // Remove URLs with potential tenant/customer info
    .replace(/https?:\/\/[^\s"']+/g, '[url]')
    // Remove GUIDs (could be customer IDs)
    .replace(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gi, '[guid]')
    // Remove IP addresses
    .replace(/\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g, '[ip]');
  
  // If this is an external error (Kusto, Azure, etc.), use generic message
  if (isExternalError(message)) {
    return categorizeExternalError(message);
  }
  
  return sanitized;
}

/**
 * Detect if error is from external service (not our repo)
 */
function isExternalError(message: string): boolean {
  const externalIndicators = [
    'Kusto',
    'Azure',
    'Application Insights',
    'authentication',
    'AADSTS',  // Azure AD error codes
    'https.ingest.monitor.azure.com',
    'RequestId:',
    'CorrelationId:'
  ];
  
  return externalIndicators.some(indicator => 
    message.toLowerCase().includes(indicator.toLowerCase())
  );
}

/**
 * Categorize external errors generically
 */
function categorizeExternalError(message: string): string {
  const msg = message.toLowerCase();
  
  if (msg.includes('kusto') || msg.includes('query')) {
    return 'External: Kusto query error';
  }
  if (msg.includes('auth') || msg.includes('token') || msg.includes('aadsts')) {
    return 'External: Authentication error';
  }
  if (msg.includes('network') || msg.includes('timeout') || msg.includes('econnrefused')) {
    return 'External: Network error';
  }
  if (msg.includes('application insights')) {
    return 'External: Application Insights error';
  }
  
  return 'External: Unknown external service error';
}

/**
 * Categorize error by source
 */
function categorizeError(error: Error, sanitizedStack: string): string {
  // Has repo frames → internal error
  if (sanitizedStack.length > 0) {
    return 'RepoInternal';
  }
  
  // Check error type and message for categorization
  const message = error.message.toLowerCase();
  
  if (error.name === 'TypeError' || error.name === 'ReferenceError') {
    return 'RepoInternal';
  }
  
  if (message.includes('kusto')) return 'ExternalKusto';
  if (message.includes('auth')) return 'ExternalAuth';
  if (message.includes('network')) return 'ExternalNetwork';
  if (message.includes('azure')) return 'ExternalAzure';
  
  return 'ExternalUnknown';
}

/**
 * Sanitize external errors for dependency tracking
 */
function sanitizeExternalError(error: any): { type: string; category: string } {
  return {
    type: error.name || 'Error',
    category: categorizeError(error, '')
  };
}
```

**What gets tracked**:
- ✅ Errors from repo code (with sanitized stack traces)
- ✅ Error categories for external services ('ExternalKusto', 'ExternalAuth', etc.)
- ❌ Detailed Kusto error messages (may contain customer data)
- ❌ Azure error details (may contain tenant/subscription info)
- ❌ Any file paths, URLs, emails, GUIDs, or IPs

### 11.3 Request Correlation

For distributed debugging, link related events:

```typescript
// Extension command handler
const correlationId = generateGuid();

usageTelemetry.trackEvent('Extension.CommandInvoked', {
  correlationId,
  commandName: 'runQuery'
});

try {
  const result = await mcpClient.request('query_telemetry', {
    kql: '...',
    _correlationId: correlationId
  });
  
  usageTelemetry.trackEvent('Extension.CommandCompleted', {
    correlationId,
    success: true
  });
} catch (error) {
  usageTelemetry.trackException(error, {
    correlationId,
    component: 'extension',
    operation: 'runQuery'
  });
}
```

**In Application Insights**, query by `correlationId` to see the full flow:

```kusto
union customEvents, exceptions, dependencies
| where customDimensions.correlationId == "abc-123"
| project timestamp, name, customDimensions, duration
| order by timestamp asc
```

### 11.3 Environment Context

Include environment info for debugging platform-specific issues:

```typescript
const commonProperties = {
  version: extensionVersion,
  vsCodeVersion: vscode.version,
  os: process.platform,
  nodeVersion: process.version,
  arch: process.arch
};

// Include in all usage telemetry events
usageTelemetry.trackEvent('Extension.CommandInvoked', {
  ...commonProperties,
  commandName: 'runQuery'
});
```

---

## 12. Testing and Validation

### 12.1 Local Testing

- Use a **separate AI resource** for local/dev validation.
- Run the extension and MCP in dev mode and perform typical operations:
  - Execute a few extension commands.
  - Invoke MCP tools.
  - Run some Kusto queries (including a failing one).
- In Azure Portal, verify:
  - `customEvents` for command/tool events and Kusto events.
  - `dependencies` for Kusto calls (if tracked).
  - `exceptions` for errors.

### 12.2 Automated Tests

- Add unit tests around telemetry integration:
  - Use a **mock telemetry implementation** to assert that:
    - Commands call `trackEvent` / `trackException` with expected names/properties.
    - MCP tools log tool-specific events (e.g., `Mcp.QueryTelemetry`, `Mcp.GetSavedQueries`) with `durationMs`.
    - Kusto helper logs `Kusto.QueryExecuted` with a measurement.
- Ensure tests do **not** perform real network calls to Application Insights.

---

## 13. Sample Analysis Queries (in Application Insights)

Once telemetry is flowing, these Kusto queries (in the AI workspace) answer the original questions.

### 13.1 Which Extension Commands Are Used?

```kusto
customEvents
| where name == "Extension.CommandCompleted"
| summarize count() by tostring(customDimensions.commandName)
| order by count_ desc
```

### 13.2 How Long Does KQL Take?

```kusto
customEvents
| where name == "Kusto.QueryExecuted"
| extend durationMs = todouble(customMeasurements.durationMs)
| summarize
    avgDurationMs = avg(durationMs),
    p95DurationMs = percentile(durationMs, 95)
  by tostring(customDimensions.queryName)
| order by p95DurationMs desc
```

### 13.3 Which MCP Tools Are Used?

```kusto
customEvents
| where name startswith "Mcp." and name !in ("Mcp.ServerStarted", "Mcp.ConfigurationLoaded", "Mcp.Error")
| summarize
    invocations = count(),
    failures = countif(tobool(customDimensions.success) == false),
    avgDuration = avg(todouble(customMeasurements.durationMs))
  by toolName = name
| order by invocations desc
```

### 13.4 Error Hotspots

```kusto
exceptions
| summarize count() by
    tostring(customDimensions.component),
    tostring(customDimensions.errorType),
    tostring(customDimensions.stackHash)
| order by count_ desc
```

### 13.5 End-to-End Request Tracing

```kusto
let correlationId = "abc-123-def-456";  // From a specific error or command
union customEvents, exceptions, dependencies
| where customDimensions.correlationId == correlationId
| project 
    timestamp,
    eventType = itemType,
    name,
    component = tostring(customDimensions.component),
    success = tostring(customDimensions.success),
    duration = customMeasurements.durationMs,
    errorType = tostring(customDimensions.errorType)
| order by timestamp asc
```

This shows the full flow: Extension.CommandInvoked → Mcp.QueryTelemetry (or other tool event) → Kusto dependency → Results

### 13.6 Performance by Profile

```kusto
dependencies
| where name == "Kusto"
| extend profileHash = tostring(customDimensions.profileHash)
| summarize 
    avgDuration = avg(duration),
    p95Duration = percentile(duration, 95),
    requestCount = count()
  by profileHash
| order by requestCount desc
```

---

## 14. Complete Event Catalog

This section lists all telemetry events with their IDs, custom dimensions, and measurements.

### Event ID Convention
- **Format**: `TB-{Component}-{Number}`
- **Components**: EXT (Extension), MCP (MCP Server), KQL (Kusto), CACHE, AUTH, CHAT, MIG (Migration)
- **Example**: `TB-EXT-001`, `TB-MCP-001`, `TB-KQL-001`

---

### 14.1 Extension Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-EXT-001** | `Extension.CommandInvoked` | `eventId`, `commandName`, `correlationId`, `sessionId`, `userId`, `version`, `profileHash`, `vsCodeVersion`, `os`, `timestamp` | - |
| **TB-EXT-002** | `Extension.CommandCompleted` | `eventId`, `commandName`, `correlationId`, `sessionId`, `userId`, `success`, `errorType`, `profileHash`, `timestamp` | `durationMs` |
| **TB-EXT-003** | `Extension.McpRequestSent` | `eventId`, `correlationId`, `method`, `sessionId`, `userId`, `profileHash`, `timestamp` | - |
| **TB-EXT-004** | `Extension.McpResponseReceived` | `eventId`, `correlationId`, `method`, `sessionId`, `success`, `statusCode`, `timestamp` | `durationMs` |
| **TB-EXT-005** | `Extension.ProfileSwitched` | `eventId`, `fromProfileHash`, `toProfileHash`, `sessionId`, `userId`, `timestamp` | - |
| **TB-EXT-006** | `Extension.CacheCleared` | `eventId`, `sessionId`, `userId`, `component`, `timestamp` | `itemsCleared`, `bytesFreed` |
| **TB-EXT-007** | `Extension.SetupWizardOpened` | `eventId`, `trigger`, `sessionId`, `userId`, `timestamp` | - |
| **TB-EXT-008** | `Extension.SetupWizardCompleted` | `eventId`, `authFlow`, `hasAppInsights`, `hasKusto`, `sessionId`, `userId`, `timestamp` | `durationMs` |
| **TB-EXT-009** | `Extension.Error` | `eventId`, `errorType`, `operation`, `correlationId`, `commandName`, `stackHash`, `sessionId`, `userId`, `timestamp` | - |

---

### 14.2 MCP Server Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-MCP-001** | `Mcp.ServerStarted` | `eventId`, `sessionId`, `port`, `configSource`, `profileCount`, `version`, `nodeVersion`, `os`, `timestamp` | - |
| **TB-MCP-002** | `Mcp.ConfigurationLoaded` | `eventId`, `source`, `hasMultipleProfiles`, `profileCount`, `validationErrors`, `sessionId`, `timestamp` | - |
| **TB-MCP-005** | `Mcp.Error` | `eventId`, `errorType`, `operation`, `correlationId`, `toolName`, `stackHash`, `sessionId`, `profileHash`, `timestamp` | - |

### 14.2.1 MCP Tool Events (Per Tool)

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-MCP-101** | `Mcp.QueryTelemetry` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `queryName`, `cacheHit`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs`, `resultRowCount` |
| **TB-MCP-102** | `Mcp.GetSavedQueries` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs`, `queryCount` |
| **TB-MCP-103** | `Mcp.SearchQueries` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `searchTerms`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs`, `resultCount` |
| **TB-MCP-104** | `Mcp.SaveQuery` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `queryName`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs` |
| **TB-MCP-105** | `Mcp.GenerateKQL` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `useContext`, `includeExternal`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs` |
| **TB-MCP-106** | `Mcp.GetRecommendations` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs`, `recommendationCount` |
| **TB-MCP-107** | `Mcp.LookupEvent` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `eventIdLookup`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs` |

---

### 14.3 Authentication Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-AUTH-001** | `Auth.AuthenticationAttempt` | `eventId`, `authFlow`, `correlationId`, `profileHash`, `sessionId`, `timestamp` | - |
| **TB-AUTH-002** | `Auth.AuthenticationCompleted` | `eventId`, `authFlow`, `success`, `errorType`, `userHash`, `profileHash`, `sessionId`, `timestamp` | `durationMs` |
| **TB-AUTH-003** | `Auth.TokenRefreshed` | `eventId`, `authFlow`, `success`, `profileHash`, `sessionId`, `timestamp` | `durationMs` |
| **TB-AUTH-004** | `Auth.Failed` | `eventId`, `authFlow`, `errorType`, `correlationId`, `profileHash`, `stackHash`, `sessionId`, `timestamp` | `attemptCount` |

---

### 14.4 Kusto Query Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-KQL-001** | `Kusto.QueryExecuted` (Dependency) | `eventId`, `queryName`, `correlationId`, `clusterHash`, `databaseHash`, `cacheHit`, `profileHash`, `component`, `sessionId`, `timestamp` | `durationMs`, `rowCount`, `resultSizeKb` |
| **TB-KQL-002** | `Kusto.QueryFailed` | `eventId`, `queryName`, `errorType`, `correlationId`, `clusterHash`, `databaseHash`, `statusCode`, `profileHash`, `stackHash`, `sessionId`, `timestamp` | `attemptCount`, `durationMs` |
| **TB-KQL-003** | `Kusto.QueryCached` | `eventId`, `queryName`, `cacheAge`, `profileHash`, `sessionId`, `timestamp` | `cacheSizeKb` |
| **TB-KQL-004** | `Kusto.CacheMiss` | `eventId`, `queryName`, `reason`, `profileHash`, `sessionId`, `timestamp` | - |

---

### 14.5 Cache Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-CACHE-001** | `Cache.Hit` | `eventId`, `cacheKey`, `component`, `sessionId`, `timestamp` | `ageSeconds`, `sizeKb` |
| **TB-CACHE-002** | `Cache.Miss` | `eventId`, `cacheKey`, `reason`, `component`, `sessionId`, `timestamp` | - |
| **TB-CACHE-003** | `Cache.Set` | `eventId`, `cacheKey`, `component`, `sessionId`, `timestamp` | `ttlSeconds`, `sizeKb` |
| **TB-CACHE-004** | `Cache.Cleared` | `eventId`, `component`, `sessionId`, `userId`, `trigger`, `timestamp` | `itemCount`, `totalSizeKb` |
| **TB-CACHE-005** | `Cache.Expired` | `eventId`, `cacheKey`, `component`, `sessionId`, `timestamp` | `ageSeconds` |

---

### 14.6 Chat Participant Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-CHAT-001** | `Chat.MessageReceived` | `eventId`, `correlationId`, `sessionId`, `userId`, `profileHash`, `chatMode`, `timestamp` | `messageLength` |
| **TB-CHAT-002** | `Chat.ResponseSent` | `eventId`, `correlationId`, `sessionId`, `toolsUsed`, `success`, `errorType`, `timestamp` | `durationMs`, `tokenCount` |
| **TB-CHAT-003** | `Chat.ToolRecommended` | `eventId`, `toolName`, `correlationId`, `sessionId`, `timestamp` | - |
| **TB-CHAT-004** | `Chat.QueryGenerated` | `eventId`, `correlationId`, `queryType`, `sessionId`, `hasExternalRefs`, `timestamp` | `generationTimeMs` |

---

### 14.7 Migration Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-MIG-001** | `Migration.Started` | `eventId`, `fromVersion`, `toVersion`, `hasLegacySettings`, `sessionId`, `userId`, `timestamp` | - |
| **TB-MIG-002** | `Migration.Completed` | `eventId`, `fromVersion`, `toVersion`, `success`, `settingsMigrated`, `profilesCreated`, `sessionId`, `userId`, `timestamp` | `durationMs` |
| **TB-MIG-003** | `Migration.Failed` | `eventId`, `fromVersion`, `toVersion`, `errorType`, `step`, `stackHash`, `sessionId`, `userId`, `timestamp` | - |

---

### 14.8 Common Dimensions Reference

All events should include these **standard dimensions**:

| Dimension | Type | Description | Example |
|-----------|------|-------------|---------|
| `eventId` | string | Event identifier (TB-XXX-NNN) | `TB-EXT-001` |
| `timestamp` | string | ISO 8601 timestamp | `2025-11-20T14:30:00.000Z` |
| `sessionId` | string | Session GUID (per process) | `a1b2c3d4-e5f6-...` |
| `userId` | string | Hashed user identifier | `f4e3d2c1b0a9...` |
| `correlationId` | string | Request correlation GUID | `x1y2z3a4-b5c6-...` |
| `version` | string | Extension/MCP version | `1.0.5` |
| `component` | string | Component name | `extension`, `mcp`, `shared` |
| `profileHash` | string | Hashed profile name | `a1b2c3d4e5f6` |

**Optional dimensions** (context-specific):
| Dimension | Type | Description |
|-----------|------|-------------|
| `success` | boolean | Operation success flag |
| `errorType` | string | Error class name |
| `stackHash` | string | Hashed stack trace (first 5 frames) |
| `os` | string | Operating system |
| `vsCodeVersion` | string | VS Code version |
| `nodeVersion` | string | Node.js version |

---

### 14.9 Sampling Configuration by Event

```json
{
  "telemetry": {
    "samplingRules": {
      "TB-EXT-001": 100,  // Command invoked - always track
      "TB-EXT-002": 100,  // Command completed - always track
      "TB-EXT-009": 100,  // Extension errors - always track
      "TB-MCP-005": 100,  // MCP errors - always track
      "TB-MCP-101": 100,  // QueryTelemetry - always track
      "TB-MCP-102": 100,  // GetSavedQueries - always track
      "TB-MCP-103": 100,  // SearchQueries - always track
      "TB-MCP-104": 100,  // SaveQuery - always track
      "TB-MCP-105": 100,  // GenerateKQL - always track
      "TB-MCP-106": 100,  // GetRecommendations - always track
      "TB-MCP-107": 100,  // LookupEvent - always track
      "TB-KQL-001": 25,   // Kusto query (success) - 25% sample
      "TB-KQL-002": 100,  // Kusto query failed - always track
      "TB-KQL-003": 10,   // Query cached - 10% sample (high volume)
      "TB-AUTH-001": 100, // Auth attempt - always track
      "TB-AUTH-002": 100, // Auth completed - always track
      "TB-AUTH-004": 100, // Auth failed - always track
      "TB-CACHE-001": 5,  // Cache hit - 5% sample (very high volume)
      "TB-CACHE-002": 25, // Cache miss - 25% sample
      "TB-CACHE-004": 100, // Cache cleared - always track
      "TB-CHAT-001": 50,  // Chat message - 50% sample
      "TB-CHAT-002": 50,  // Chat response - 50% sample
      "TB-MIG-001": 100,  // Migration - always track
      "TB-MIG-002": 100,  // Migration - always track
      "TB-MIG-003": 100   // Migration - always track
    }
  }
}
```

---

### 14.10 Usage Example

**Extension Command Handler:**
```typescript
const correlationId = generateGuid();
const startTime = Date.now();

usageTelemetry.trackEvent('Extension.CommandInvoked', {
  eventId: 'TB-EXT-001',
  commandName: 'runQuery',
  correlationId,
  sessionId: this.sessionId,
  installationId: this.installationId,  // Random, not tied to user
  version: this.extensionVersion,
  profileHash: hashValue(this.currentProfile),
  vsCodeVersion: vscode.version,
  os: process.platform,
  timestamp: new Date().toISOString()
});

try {
  // Execute command...
  const result = await this.executeCommand();
  
  usageTelemetry.trackEvent('Extension.CommandCompleted', {
    eventId: 'TB-EXT-002',
    commandName: 'runQuery',
    correlationId,
    sessionId: this.sessionId,
    installationId: this.installationId,
    success: 'true',
    profileHash: hashValue(this.currentProfile),
    timestamp: new Date().toISOString()
  }, {
    durationMs: Date.now() - startTime
  });
} catch (error) {
  usageTelemetry.trackException(error, {
    eventId: 'TB-EXT-009',
    errorType: error.name,
    operation: 'runQuery',
    correlationId,
    commandName: 'runQuery',
    stackHash: hashStack(error.stack),
    sessionId: this.sessionId,
    installationId: this.installationId,
    timestamp: new Date().toISOString()
  });
}
```

**MCP Tool Handler (QueryTelemetry example):**
```typescript
const requestId = generateGuid();
const correlationId = req.body.params?._correlationId || generateGuid();
const startTime = Date.now();

try {
  // Execute the tool logic...
  const result = await this.executeQueryTelemetry(params);
  
  usageTelemetry.trackEvent('Mcp.QueryTelemetry', {
    eventId: 'TB-MCP-101',
    requestId,
    correlationId,
    success: 'true',
    caller: params.caller || 'extension',
    queryName: getQueryName(params.kql),
    cacheHit: result.cached.toString(),
    profileHash: hashValue(this.currentProfile),
    sessionId: this.sessionId,
    installationId: this.installationId,
    component: 'mcp',
    timestamp: new Date().toISOString()
  }, {
    durationMs: Date.now() - startTime,
    resultRowCount: result.rows?.length || 0
  });
  
  return result;
} catch (error) {
  usageTelemetry.trackEvent('Mcp.QueryTelemetry', {
    eventId: 'TB-MCP-101',
    requestId,
    correlationId,
    success: 'false',
    errorType: error.name,
    caller: params.caller || 'extension',
    profileHash: hashValue(this.currentProfile),
    sessionId: this.sessionId,
    installationId: this.installationId,
    component: 'mcp',
    timestamp: new Date().toISOString()
  }, {
    durationMs: Date.now() - startTime
  });
  
  usageTelemetry.trackException(error, {
    eventId: 'TB-MCP-005',
    errorType: error.name,
    operation: 'QueryTelemetry',
    correlationId,
    toolName: 'query_telemetry',
    stackHash: hashStack(error.stack),
    sessionId: this.sessionId,
    profileHash: hashValue(this.currentProfile),
    timestamp: new Date().toISOString()
  });
  
  throw error;
}
```

**MCP Kusto Dependency (within tool execution):**
```typescript
const startTime = Date.now();

try {
  const result = await kustoClient.execute(kql, token);
  
  // Hash cluster/database for privacy
  const clusterHash = hashValue(cluster).substring(0, 8);
  const databaseHash = hashValue(database).substring(0, 8);
  
  usageTelemetry.trackDependency(
    'Kusto',
    `${clusterHash}/${databaseHash}`,
    Date.now() - startTime,
    true,
    '200',
    {
      eventId: 'TB-KQL-001',
      queryName: 'ErrorsByDay',
      correlationId,
      clusterHash,
      databaseHash,
      cacheHit: 'false',
      profileHash: hashValue(profileName),
      component: 'mcp',
      sessionId: this.sessionId,
      timestamp: new Date().toISOString()
    }
  );
} catch (error) {
  const clusterHash = hashValue(cluster).substring(0, 8);
  const databaseHash = hashValue(database).substring(0, 8);
  
  usageTelemetry.trackEvent('Kusto.QueryFailed', {
    eventId: 'TB-KQL-002',
    queryName: 'ErrorsByDay',
    errorType: error.name,
    correlationId,
    clusterHash,
    databaseHash,
    statusCode: error.statusCode || '500',
    profileHash: hashValue(profileName),
    stackHash: hashStack(error.stack),
    sessionId: this.sessionId,
    timestamp: new Date().toISOString()
  }, {
    attemptCount: 1,
    durationMs: Date.now() - startTime
  });
}
```

---

## 15. Implementation Checklist

**Shared Package**
- [ ] Create `shared/src/usageTelemetry.ts` with `IUsageTelemetry` interface
- [ ] Implement `NoOpUsageTelemetry` (when disabled or connection string missing)
- [ ] Implement `RateLimitedUsageTelemetry` wrapper (Section 2)
- [ ] Implement `TelemetryLevelFilter` (VS Code level support - Section 3.2)
- [ ] Add telemetry config to `shared/src/config.ts` (global + per-profile, excluding connection string)
- [ ] Add utility functions: `generateGuid()`, `hashValue()`, `sanitizeStackTrace()`, `sanitizeErrorMessage()`, `categorizeError()`
- [ ] Create `shared/src/telemetryConfig.generated.ts` template (gitignored) for CI injection

**Extension**
- [ ] Install `@vscode/extension-telemetry` package
- [ ] Implement `VSCodeUsageTelemetry` wrapper around `TelemetryReporter`
- [ ] **Check `telemetry.telemetryLevel` setting** (VS Code marketplace requirement)
- [ ] **Support all four telemetry levels**: `off`, `crash`, `error`, `all`
- [ ] Support legacy `vscode.env.isTelemetryEnabled` for backward compatibility
- [ ] Initialize in `activate()`, check telemetry level and connection string presence
- [ ] Import `TELEMETRY_CONNECTION_STRING` from generated file, fall back to `NoOpUsageTelemetry` if missing
- [ ] Wrap all usage telemetry initialization and calls in try/catch (never fail commands)mands)
- [ ] **Create telemetry stack**: Reporter → VSCode wrapper → Rate limiter → Level filter
- [ ] **Generate random `installationId` in extension global state** (persistent, not from machineId)
- [ ] **Register command `bcTelemetryBuddy.resetTelemetryId`** (allows users to reset their ID)
- [ ] Wrap command handlers with correlation ID and usage telemetry
- [ ] **Use `sanitizeStackTrace()` and `sanitizeErrorMessage()` for all exceptions**
- [ ] Add error telemetry in key services (`mcpClient`, `migrationService`)
- [ ] Pass `correlationId` to MCP requests
- [ ] Add common properties: `sessionId`, `installationId` (random), `version`, `os`

**MCP Backend**
- [ ] Install `applicationinsights` package
- [ ] Implement `AppInsightsUsageTelemetry` using AI SDK
- [ ] Add telemetry config reading from `.bctb-config.json` (enabled, environment, sampling only)
- [ ] Import `TELEMETRY_CONNECTION_STRING` from generated file, fall back to `NoOpUsageTelemetry` if missing
- [ ] Wrap all usage telemetry initialization and calls in try/catch (never fail MCP operations)
- [ ] **Generate random `installationId` per workspace** (stored in `.bctb-installation-id`)
- [ ] **Add `.bctb-installation-id` to `.gitignore` automatically**
- [ ] Initialize in server startup with connection string
- [ ] Create Express middleware for request correlation
- [ ] Wrap MCP tool handlers with usage telemetry (invoked/completed)
- [ ] **Use `trackDependency` for Kusto calls WITHOUT cluster/database identifiers**
- [ ] **Use `sanitizeExternalError()` for all Kusto/Azure errors**
- [ ] Add error telemetry with stack hashing (repo frames only)
- [ ] Implement sampling logic (per event type)
- [ ] Add common properties: `sessionId`, `installationId`, `profileHash`

**Configuration & CI**
- [ ] Update `.bctb-config.json` schema with `telemetry` section (enabled, environment, sampling - NO connection string)
- [ ] Support per-profile overrides (for sampling, environment tagging)
- [ ] Add `AI_CONNECTION_STRING` to CI secrets (GitHub Actions / Azure DevOps)
- [ ] Update CI build workflow to inject connection string into generated file before compilation
- [ ] Add `shared/src/telemetryConfig.generated.ts` to `.gitignore`
- [ ] Create separate dev/prod AI resources (dev for local testing, prod for releases)
- [ ] Document local dev setup with `.env` file for `AI_CONNECTION_STRING`
- [ ] **Set up Azure cost budget alerts** ($50/month starting point)
- [ ] **Configure anomaly detection alerts** (ingestion spike, error spike, user spike)
- [ ] **Document connection string rotation procedure**

**Docs & Tests**
- [ ] Update `docs/UserGuide.md` with usage telemetry section (what's collected, privacy, how to disable)
- [ ] **Document `Reset Telemetry ID` command** (how to reset, why, GDPR compliance)
- [ ] Document sampling strategy and cost estimates
- [ ] Add unit tests using mock `IUsageTelemetry` implementation
- [ ] Test correlation flow: Extension → MCP → Kusto
- [ ] Validate telemetry end‑to‑end in a dev AI resource
- [ ] Create example analysis queries in Application Insights
- [ ] **Test installation ID persistence** (survives restart, command resets it)
- [ ] **Verify `.bctb-installation-id` is gitignored**
