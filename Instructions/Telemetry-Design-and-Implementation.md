# Telemetry Design and Implementation for BCTelemetryBuddy

## Purpose and Scope

This document describes how to design and implement telemetry for the BCTelemetryBuddy **VS Code extension** and **MCP backend** using Azure Application Insights.

Goals:
- Track **which commands** are being used in the extension.
- Measure **how long Kusto (KQL) queries take** end‑to‑end.
- Track **which MCP tools** are used, how often, and how they perform.
- Capture **errors and failures** with enough context to debug, without collecting sensitive data.

All telemetry must respect user privacy, be configurable/disable‑able, and comply with VS Code marketplace and Azure policies.

---

## 1. Application Insights Setup

### 1.1 Create / Select Application Insights Resource

1. In Azure Portal, create (or reuse) an **Application Insights** resource.
2. Retrieve the **Connection String** (preferred) or **Instrumentation Key**.
3. Use a **single AI resource** for both Extension and MCP.
   - All telemetry from all users flows to this one resource.
   - Distinguish signals with a `component` property (`extension` vs. `mcp`).

### 1.2 Connection String Handling

**Fixed, Non-Configurable Connection String:**

- The Application Insights connection string is **hardcoded into shipped binaries** (VSIX for extension, npm package for MCP).
- It is **NOT** stored in the repository or user-configurable at runtime.
- Users cannot override or change where telemetry is sent.

**CI Build-Time Injection:**

1. Store the connection string as a **CI secret** (e.g., GitHub Actions secret, Azure DevOps variable).
2. During the build process, inject it into the code:
   - Create a generated file (e.g., `shared/src/telemetryConfig.generated.ts`):
     ```typescript
     // Auto-generated by CI - DO NOT COMMIT
     export const TELEMETRY_CONNECTION_STRING = process.env.AI_CONNECTION_STRING || '';
     ```
   - Add this file to `.gitignore` to prevent accidental commits.
   - CI workflow sets `AI_CONNECTION_STRING` environment variable before building.
3. Extension and MCP import this constant at initialization.

**Local Development:**

- For local dev/testing, use a separate dev AI resource.
- Create a local `.env` file (gitignored) with:
  ```
  AI_CONNECTION_STRING=InstrumentationKey=...;IngestionEndpoint=...
  ```
- The generated file reads from `process.env.AI_CONNECTION_STRING`.

**Security Trade-offs:**

- The connection string exists in compiled artifacts and could be extracted by determined users.
- This is generally acceptable for Application Insights (write-only ingestion endpoint).
- Treat it as sensitive; rotate if compromised.
- Given everyone runs locally with no shared identity, this is the only practical way to achieve "one shared connection string for all users."

**Best-Effort Telemetry:**

- Telemetry must **never affect extension or MCP behavior**.
- If connection string is missing or invalid:
  - Use `NoOpUsageTelemetry` (silent no-op implementation).
  - No error messages, no command failures.
- All telemetry calls are fire-and-forget with try/catch wrappers.

### 1.3 Configuration Model

**What Users Can Configure:**

Users can control telemetry behavior via VS Code settings and `.bctb-config.json`, but **NOT** the connection string (which is fixed).

#### VS Code Extension Settings

The extension automatically respects VS Code's global telemetry setting (`vscode.env.isTelemetryEnabled`). No additional extension-specific setting is needed for enable/disable.

Optional setting in `package.json` for advanced users:
- `bcTelemetryBuddy.telemetry.environment` (string: "dev" | "test" | "prod") - for separating dev/prod telemetry

#### .bctb-config.json Structure

Add a **global `telemetry` section** to `.bctb-config.json` with optional per-profile overrides:

```json
{
  "telemetry": {
    "enabled": true,
    "environment": "prod",
    "samplingPercentage": 100
  },
  "profiles": {
    "production-customer": {
      "connectionName": "Acme Corp",
      "applicationInsightsAppId": "..."
    },
    "dev-testing": {
      "connectionName": "Dev Environment",
      "applicationInsightsAppId": "...",
      "telemetry": {
        "environment": "dev",
        "samplingPercentage": 10
      }
    }
  }
}
```

**Configuration hierarchy**:
1. Global `telemetry` block applies to all profiles
2. Per-profile `telemetry` overrides global settings
3. Extension reads config for enable/disable and sampling only
4. MCP reads same config when spawned by extension
5. Connection string is **NOT** in config - it's compiled into the binaries

**Environment variables (backward compatibility)**:
- `BC_TB_TELEMETRY_ENABLED` (true/false) - enable/disable only
- `BC_TB_TELEMETRY_ENVIRONMENT` (dev/test/prod) - environment tagging
- ~~`BC_TB_TELEMETRY_CONNECTION_STRING`~~ - **REMOVED** (use CI-injected constant instead)

---

## 2. Telemetry Abstraction

To keep the implementation clean and testable, introduce an explicit telemetry abstraction that can be used by both Extension and MCP.

**⚠️ IMPORTANT NAMING**: The project already has a `TelemetryService` class in `packages/extension/src/services/telemetryService.ts` that is used for **querying Business Central telemetry** (executing KQL against Application Insights). The new telemetry for **tracking usage** of the extension/MCP should use a different name to avoid confusion.

**Recommended naming**:
- **UsageTelemetryService**: For tracking extension/MCP usage
- **TelemetryService**: Existing service for querying BC telemetry (keep as-is)

### 2.1 Usage Telemetry Interface (shared)

Create a TypeScript interface in `shared/src/usageTelemetry.ts`:

```typescript
export interface IUsageTelemetry {
    trackEvent(name: string, properties?: Record<string, string | number | boolean>, measurements?: Record<string, number>): void;
    trackDependency(name: string, data: string, durationMs: number, success: boolean, resultCode?: string, properties?: Record<string, string>): void;
    trackException(error: Error, properties?: Record<string, string>): void;
    trackTrace(message: string, properties?: Record<string, string>): void;
    flush(): Promise<void>;
}
```

Concrete implementations:
- **AppInsightsUsageTelemetry**: Sends data to Application Insights (for MCP backend).
- **VSCodeUsageTelemetry**: Uses `@vscode/extension-telemetry` TelemetryReporter (for extension).
- **NoOpUsageTelemetry**: Used when telemetry is disabled or configuration is missing.

### 2.2 Extension vs MCP Implementation

**Extension (VS Code)**:
- Use **`@vscode/extension-telemetry`** package (official VS Code telemetry API)
- Automatically respects user's global telemetry preference (`vscode.env.isTelemetryEnabled`)
- Requires `TelemetryReporter` initialized with your AI instrumentation key
- Aligns with VS Code marketplace guidelines

```typescript
import TelemetryReporter from '@vscode/extension-telemetry';

const reporter = new TelemetryReporter('your-instrumentation-key');
// Wrap in IUsageTelemetry interface for consistency
```

**MCP Backend (Node.js)**:
- Use **`applicationinsights`** SDK directly
- Manual configuration of telemetry enabled/disabled via config
- Express middleware for automatic request tracking

```typescript
import * as appInsights from 'applicationinsights';

appInsights.setup('your-connection-string')
    .setAutoCollectRequests(true)
    .setAutoCollectDependencies(true)
    .start();
```

### 2.3 Initialization Pattern

- Initialize telemetry **once per process**:
  - **Extension**: in `activate` (in `packages/extension/src/extension.ts`).
    - Check `vscode.env.isTelemetryEnabled` before initializing
    - Import `TELEMETRY_CONNECTION_STRING` from the CI-generated file
    - If connection string is empty/missing → use `NoOpUsageTelemetry`
    - Otherwise, create `VSCodeUsageTelemetry` wrapper around `TelemetryReporter`
    - Wrap initialization in try/catch; on error → fall back to `NoOpUsageTelemetry`
  - **MCP**: in `server` startup (in `packages/mcp/src/server.ts`).
    - Check config `telemetry.enabled` flag
    - Import `TELEMETRY_CONNECTION_STRING` from the CI-generated file
    - If disabled or connection string missing → use `NoOpUsageTelemetry`
    - Otherwise, initialize `applicationinsights` SDK with connection string
    - Wrap initialization in try/catch; on error → fall back to `NoOpUsageTelemetry`
- Inject or export the `IUsageTelemetry` instance for other modules to use.
- **CRITICAL: Telemetry must never affect behavior**:
  - All `trackEvent/trackDependency/trackException` calls must be fire-and-forget
  - Wrap all telemetry calls in try/catch and swallow exceptions silently
  - No user-facing error messages or command failures when telemetry fails
- **Add to package dependencies**:
  - Extension: `npm install @vscode/extension-telemetry`
  - MCP: `npm install applicationinsights`

---

## 3. Extension Telemetry (VS Code)

### 3.1 Command Usage

For every command contributed by the extension (registered in `extension.ts`):

1. Wrap the command handler in a helper like `runWithTelemetry(commandName, handler)`.
2. On invocation:
   - Record `startTime = Date.now()`.
   - Optionally send `Extension.CommandInvoked` with properties:
     - `commandName`
     - `source = "extension"`
     - `version` (extension version)
     - `profileIdHash`, `chatMode`, etc. (if applicable and non‑sensitive).
3. On completion:
   - Compute `durationMs = Date.now() - startTime`.
   - Send `Extension.CommandCompleted` with:
     - `commandName`
     - `success` (true/false)
     - `errorType` (if failed, e.g. `ValidationError`, `McpError`)
     - `errorMessageShort` (short, non‑PII description)
   - Add `durationMs` as a measurement.

This yields:
- **What commands are used** (by counting `Extension.CommandCompleted` by `commandName`).
- **How long they take** (using the `durationMs` measurement).

### 3.2 Extension Errors

Whenever a command or background operation throws:

- Catch the error at the highest sensible layer.
- Call `trackException(error, { component: "extension", commandName, operation })`.
- Do not log sensitive details (no raw queries, no file contents, no tokens).

Optionally, add a tiny wrapper for command registration that always applies try/catch and telemetry.

---

## 4. MCP Telemetry

### 4.1 MCP Tool Usage & Request Correlation

Each MCP tool (method exposed by the MCP server) should send telemetry on invocation and completion.

**Request Correlation Pattern**:

The extension should pass a `correlationId` to the MCP server for end-to-end tracing:

```typescript
// Extension (mcpClient.ts)
const correlationId = generateGuid();
const response = await mcpClient.request('query_telemetry', {
  kql: '...',
  _correlationId: correlationId  // Pass to MCP
});

telemetry.trackEvent('Extension.McpRequestSent', {
  correlationId,
  method: 'query_telemetry'
});
```

```typescript
// MCP Server (server.ts)
app.post('/jsonrpc', async (req, res) => {
  const correlationId = req.body.params?._correlationId || generateGuid();
  const requestId = generateGuid(); // MCP-specific ID
  
  telemetry.trackEvent('Mcp.RequestReceived', {
    correlationId,  // Links to extension
    requestId,      // MCP-specific
    method: req.body.method
  });
});
```

**Pattern per tool handler**:

1. **On entry**:
   - Extract `correlationId` from request params (or generate if missing)
   - Generate a `requestId` (GUID, MCP-specific)
   - Record `startTime`

2. **On completion (success or failure)**:
   - Compute `durationMs`
   - Send tool-specific event (e.g., `Mcp.QueryTelemetry`, `Mcp.GetSavedQueries`) with properties:
     - `eventId` (tool-specific, e.g., `TB-MCP-101`, `TB-MCP-102`)
     - `requestId`
     - `correlationId`
     - `success` (true/false)
     - `errorType` (if failed)
     - `caller` (if known, e.g. `extension`, `cli`)
     - `component = "mcp"`
     - Domain-specific context, e.g. `queryName`, `cacheHit`, etc.
   - Add `durationMs` as a measurement
   - If failed, also send `trackException` with full error context

**Benefits**:
- **End-to-end tracing**: Link extension command → MCP tool → Kusto query
- **Which MCP tools are used** and how often
- **How long they take** and how often they fail
- **Distributed debugging**: Find all related events by `correlationId`

### 4.2 Kusto (KQL) Performance

Wherever Kusto is called (likely in `shared/src/kusto.ts` or MCP‑specific query module):

**Use `trackDependency` for external calls** (recommended approach for Application Insights):

1. Wrap the Kusto client call in telemetry logic
2. On entry:
   - Record `startTime`
3. On completion:
   - Compute `durationMs`
   - Use `trackDependency` for automatic correlation and Application Map visualization:

```typescript
const startTime = Date.now();
try {
  const result = await kustoClient.execute(kql, token);
  const durationMs = Date.now() - startTime;
  
  // Hash cluster/database for privacy
  const clusterHash = hashValue(cluster).substring(0, 8);
  const databaseHash = hashValue(database).substring(0, 8);
  
  telemetry.trackDependency(
    'Kusto',                    // dependencyTypeName
    `${clusterHash}/${databaseHash}`,   // name (hashed)
    durationMs,                 // duration
    true,                       // success
    '200',                      // resultCode
    {
      queryName: 'SlowQueries',  // Logical name, NOT raw KQL
      correlationId,
      cacheHit: 'false',
      component: 'shared',
      clusterHash,
      databaseHash,
      rowCount: result.rows.length.toString()
    }
  );
} catch (error) {
  const durationMs = Date.now() - startTime;
  const clusterHash = hashValue(cluster).substring(0, 8);
  const databaseHash = hashValue(database).substring(0, 8);
  
  telemetry.trackDependency('Kusto', `${clusterHash}/${databaseHash}`, durationMs, false, '500', {
    queryName: 'SlowQueries',
    correlationId,
    clusterHash,
    databaseHash,
    errorType: error.name
  });
  throw error;
}
```

**Properties to include**:
- `queryName` (logical identifier, e.g., "ErrorsByDay", "SlowQueries")
- `clusterHash`, `databaseHash` (hashed for privacy, 8-char truncated SHA256)
- `cacheHit` (boolean)
- `correlationId` (for request tracing)
- `component = "mcp"` or `"shared"`
- `rowCount` (aggregated count, not actual data)

**⚠️ CRITICAL: NEVER include**:
- **KQL query text** - ANY raw query text is considered sensitive data (may contain secrets, customer-specific table names, business logic, filters with PII)
- Query results or actual row data
- User principal names, email addresses, or tenant names
- Connection strings or tokens

**How to derive `queryName` safely**:
- Use saved query names from your query library (e.g., "ErrorsByDay", "TopErrorMessages")
- For chat-generated queries: use descriptive labels like "ChatGenerated_Performance"
- For ad-hoc queries: use generic label "AdHocQuery"
- For tool-specific queries: use pattern "ToolName_QueryPurpose" (e.g., "GetRecommendations_QueryData")
- **NEVER** derive queryName from actual KQL text, table names, or customer-specific identifiers

**Benefits of `trackDependency`**:
- Automatic **Application Map** visualization showing Extension → MCP → Kusto flow
- Built-in correlation with requests
- Standard dependency metrics (duration, success rate, failures)

This yields:
- **How long KQL takes** (overall and per logical query)
- Insight into slow or failing queries
- Visual dependency graph in Application Insights

### 4.3 MCP Errors

On unhandled exceptions or explicit error paths in the MCP:

- Call `trackException(error, { component: "mcp", operation, toolName, queryName })`.
- Optionally send a separate `Mcp.Error` event with a small, structured payload.

---

## 5. Event Naming and Data Model

### 5.1 Event Names

Use consistent, hierarchical names for events:

- **Extension events**:
  - `Extension.CommandInvoked`
  - `Extension.CommandCompleted`
  - `Extension.Error`

- **MCP events** (per tool):
  - `Mcp.QueryTelemetry`
  - `Mcp.GetSavedQueries`
  - `Mcp.SearchQueries`
  - `Mcp.SaveQuery`
  - `Mcp.GenerateKQL`
  - `Mcp.GetRecommendations`
  - `Mcp.LookupEvent`
  - `Mcp.Error`

- **Kusto performance**:
  - `Kusto.QueryExecuted`
  - `Kusto.QueryFailed` (or rely on `exceptions` / dependency failures).

### 5.2 Common Properties

Define a small core set of shared dimensions applied to most events:

- `component`: `extension` | `mcp` | `shared`.
- `environment`: `dev` | `test` | `prod` (from config).
- `version`: extension or MCP version.
- `sessionId`: random GUID per process start.
- `userId`: a pseudonymous identifier (e.g. hash of something stable, or random per installation), if needed.
- `os`, `nodeVersion`, `vscodeVersion` (where known and useful).

Domain‑specific properties:

- **Commands**:
  - `commandName`, `profileIdHash`, `chatMode`, `source`.

- **MCP tools**:
  - `toolName`, `requestId`, `caller`, `queryName`.

- **Kusto**:
  - `queryName`, `clusterHash`, `databaseHash`, `cacheHit`.

- **Errors**:
  - `errorType`, `errorMessageShort`, `stackHash`, `operation`, `toolName` / `commandName`.

Measurements (numeric):
- `durationMs` for commands, tools, and queries.
- Optionally `resultRowCount`, `resultSizeKb` (aggregated, non‑sensitive).

---

## 7. Cost Control and Sampling

### 7.1 Application Insights Costs

Application Insights pricing is based on **data volume ingested** (per GB). High-frequency events can become expensive.

**Cost estimates**:
- Typical event: ~1-2 KB
- 1000 events = ~1-2 MB
- 1M events = ~1-2 GB (~$2-3/month at current Azure pricing)
- Active users generating 100+ events/day can add up quickly

### 7.2 Sampling Strategies

**Adaptive Sampling (Built-in)**:
- Application Insights SDK includes adaptive sampling by default
- Automatically reduces volume when ingestion is high
- Keeps 100% of errors and exceptions
- Recommended: Enable by default, set max rate

```typescript
// MCP backend
appInsights.setup(connectionString)
  .setAutoCollectRequests(true)
  .setAutoCollectDependencies(true)
  .setSendLiveMetrics(false)  // Disable live metrics to save cost
  .start();

// Set sampling percentage
appInsights.defaultClient.config.samplingPercentage = 100; // Start at 100%, adjust if needed
```

**Custom Sampling (Per Event Type)**:

Implement selective sampling based on event importance:

```typescript
class SampledUsageTelemetry implements IUsageTelemetry {
  trackEvent(name: string, properties?: Record<string, any>, measurements?: Record<string, number>) {
    // Always track errors and important events
    if (name.includes('Error') || name.includes('Exception') || properties?.success === false) {
      this.innerTelemetry.trackEvent(name, properties, measurements);
      return;
    }
    
    // Sample successful queries at 10%
    if (name === 'Kusto.QueryExecuted' && Math.random() < 0.1) {
      this.innerTelemetry.trackEvent(name, properties, measurements);
    }
    
    // Always track command invocations (lower volume)
    if (name.includes('Command')) {
      this.innerTelemetry.trackEvent(name, properties, measurements);
    }
  }
}
```

**Recommended sampling rates**:
- **Errors/Exceptions**: 100% (always)
- **Command invocations**: 100% (low volume)
- **MCP tool calls**: 100% (medium volume)
- **Successful Kusto queries**: 10-25% (high volume)
- **Cache hits**: 5% (very high volume, less important)

### 7.3 Configuration

Add `samplingPercentage` to `.bctb-config.json`:

```json
{
  "telemetry": {
    "enabled": true,
    "samplingPercentage": 100,
    "samplingRules": {
      "Kusto.QueryExecuted": 10,
      "Mcp.QueryTelemetry": 100,
      "Mcp.GetSavedQueries": 100,
      "Extension.CommandCompleted": 100
    }
  }
}
```

## 8. Session and User Identification

### 8.1 Session ID

Generate once per process and include in all events:

**Extension**:
```typescript
const sessionId = generateGuid(); // In activate()
// Include in all telemetry events
telemetry.trackEvent('Extension.CommandInvoked', {
  sessionId,
  commandName: 'runQuery'
});
```

**MCP Backend**:
```typescript
const sessionId = generateGuid(); // At server startup
// Include in all events
telemetry.trackEvent('Mcp.QueryTelemetry', {
  eventId: 'TB-MCP-101',
  sessionId,
  success: 'true'
});
```

### 8.2 User Identification (Pseudonymous)

**Extension**: Use VS Code machine ID (hashed for privacy):
```typescript
import { env } from 'vscode';
import * as crypto from 'crypto';

const machineId = env.machineId; // VS Code provides this
const userId = crypto.createHash('sha256').update(machineId).digest('hex').substring(0, 16);

// Include in telemetry
telemetry.trackEvent('Extension.CommandInvoked', {
  userId,  // Hashed, not directly identifiable
  sessionId
});
```

**MCP Backend**: Generate a random user ID per installation (or hash workspace path):
```typescript
import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';

function getUserId(workspacePath: string): string {
  const idFile = path.join(workspacePath, '.bctb-user-id');
  
  if (fs.existsSync(idFile)) {
    return fs.readFileSync(idFile, 'utf-8').trim();
  }
  
  // Generate new user ID
  const userId = crypto.randomBytes(16).toString('hex');
  fs.writeFileSync(idFile, userId);
  return userId;
}
```

### 8.3 Profile Correlation

Track which profile is being used (without exposing customer names):

```typescript
const profileHash = crypto.createHash('sha256')
  .update(profileName)
  .digest('hex')
  .substring(0, 12);

telemetry.trackEvent('Mcp.QueryTelemetry', {
  eventId: 'TB-MCP-101',
  profileHash,  // E.g., "a1b2c3d4e5f6" instead of "Acme Corp"
  sessionId,
  userId,
  success: 'true'
});
```

## 9. Privacy, Opt‑In, and Documentation

### 9.1 Opt‑In / Opt‑Out

- Telemetry must be **configurable**:
  - Extension automatically respects VS Code's global telemetry setting (`vscode.env.isTelemetryEnabled`)
  - No separate opt-in required for the extension
  - MCP backend telemetry controlled via `.bctb-config.json` or environment variable
- The MCP backend should follow config-driven control:
  - `telemetry.enabled = false` in `.bctb-config.json` must fully disable telemetry
  - `BC_TB_TELEMETRY_ENABLED=false` environment variable as fallback

### 9.2 Data Minimization

- Do **not** send:
  - **KQL query text** - treat ALL raw query text as sensitive (may contain secrets, customer-specific logic, table names with business context, filters with PII).
  - Kusto results or actual business data.
  - Usernames, email addresses, tenant names, or tokens.
  - Customer-specific table names, column names, or database schema information.
- Prefer short identifiers or hashes (e.g. `profileIdHash`) for correlation.
- Use logical, predefined names for `queryName` (never derived from actual KQL text).

### 9.3 User‑Facing Documentation

Update `docs/UserGuide.md` with a **Telemetry** section that explains:

- What is collected (high‑level usage, performance, errors).
- What is **not** collected (no raw data, no PII).
- How to enable/disable telemetry (settings and environment variables).
- Where telemetry is sent (Azure Application Insights, owned by you).
- How data is pseudonymized (hashed user/profile IDs).
- Sampling strategy (not all events are sent, errors always captured).

---

## 10. Enhanced Error Context

### 10.1 Stack Traces

Full stack traces can contain PII (file paths with usernames). Use a **hashing strategy**:

```typescript
function trackExceptionSafe(error: Error, properties?: Record<string, string>) {
  // Extract top 5 stack frames only
  const stack = error.stack?.split('\n').slice(0, 5).join('\n') || '';
  
  // Hash the stack for grouping without exposing paths
  const stackHash = crypto.createHash('md5').update(stack).digest('hex').substring(0, 12);
  
  telemetry.trackException(error, {
    ...properties,
    stackHash,
    errorMessage: error.message.substring(0, 200),  // Truncate long messages
    errorType: error.name
  });
}
```

**Benefits**:
- Group similar errors by `stackHash`
- No PII in stack traces
- Still enough context to identify unique error patterns

### 10.2 Request Correlation

For distributed debugging, link related events:

```typescript
// Extension command handler
const correlationId = generateGuid();

telemetry.trackEvent('Extension.CommandInvoked', {
  correlationId,
  commandName: 'runQuery'
});

try {
  const result = await mcpClient.request('query_telemetry', {
    kql: '...',
    _correlationId: correlationId
  });
  
  telemetry.trackEvent('Extension.CommandCompleted', {
    correlationId,
    success: true
  });
} catch (error) {
  telemetry.trackException(error, {
    correlationId,
    component: 'extension',
    operation: 'runQuery'
  });
}
```

**In Application Insights**, query by `correlationId` to see the full flow:

```kusto
union customEvents, exceptions, dependencies
| where customDimensions.correlationId == "abc-123"
| project timestamp, name, customDimensions, duration
| order by timestamp asc
```

### 10.3 Environment Context

Include environment info for debugging platform-specific issues:

```typescript
const commonProperties = {
  version: extensionVersion,
  vsCodeVersion: vscode.version,
  os: process.platform,
  nodeVersion: process.version,
  arch: process.arch
};

// Include in all events
telemetry.trackEvent('Extension.CommandInvoked', {
  ...commonProperties,
  commandName: 'runQuery'
});
```

---

## 11. Testing and Validation

### 11.1 Local Testing

- Use a **separate AI resource** for local/dev validation.
- Run the extension and MCP in dev mode and perform typical operations:
  - Execute a few extension commands.
  - Invoke MCP tools.
  - Run some Kusto queries (including a failing one).
- In Azure Portal, verify:
  - `customEvents` for command/tool events and Kusto events.
  - `dependencies` for Kusto calls (if tracked).
  - `exceptions` for errors.

### 11.2 Automated Tests

- Add unit tests around telemetry integration:
  - Use a **mock telemetry implementation** to assert that:
    - Commands call `trackEvent` / `trackException` with expected names/properties.
    - MCP tools log tool-specific events (e.g., `Mcp.QueryTelemetry`, `Mcp.GetSavedQueries`) with `durationMs`.
    - Kusto helper logs `Kusto.QueryExecuted` with a measurement.
- Ensure tests do **not** perform real network calls to Application Insights.

---

## 12. Sample Analysis Queries (in Application Insights)

Once telemetry is flowing, these Kusto queries (in the AI workspace) answer the original questions.

### 12.1 Which Extension Commands Are Used?

```kusto
customEvents
| where name == "Extension.CommandCompleted"
| summarize count() by tostring(customDimensions.commandName)
| order by count_ desc
```

### 12.2 How Long Does KQL Take?

```kusto
customEvents
| where name == "Kusto.QueryExecuted"
| extend durationMs = todouble(customMeasurements.durationMs)
| summarize
    avgDurationMs = avg(durationMs),
    p95DurationMs = percentile(durationMs, 95)
  by tostring(customDimensions.queryName)
| order by p95DurationMs desc
```

### 12.3 Which MCP Tools Are Used?

```kusto
customEvents
| where name startswith "Mcp." and name !in ("Mcp.ServerStarted", "Mcp.ConfigurationLoaded", "Mcp.Error")
| summarize
    invocations = count(),
    failures = countif(tobool(customDimensions.success) == false),
    avgDuration = avg(todouble(customMeasurements.durationMs))
  by toolName = name
| order by invocations desc
```

### 12.4 Error Hotspots

```kusto
exceptions
| summarize count() by
    tostring(customDimensions.component),
    tostring(customDimensions.errorType),
    tostring(customDimensions.stackHash)
| order by count_ desc
```

### 12.5 End-to-End Request Tracing

```kusto
let correlationId = "abc-123-def-456";  // From a specific error or command
union customEvents, exceptions, dependencies
| where customDimensions.correlationId == correlationId
| project 
    timestamp,
    eventType = itemType,
    name,
    component = tostring(customDimensions.component),
    success = tostring(customDimensions.success),
    duration = customMeasurements.durationMs,
    errorType = tostring(customDimensions.errorType)
| order by timestamp asc
```

This shows the full flow: Extension.CommandInvoked → Mcp.QueryTelemetry (or other tool event) → Kusto dependency → Results

### 12.6 Performance by Profile

```kusto
dependencies
| where name == "Kusto"
| extend profileHash = tostring(customDimensions.profileHash)
| summarize 
    avgDuration = avg(duration),
    p95Duration = percentile(duration, 95),
    requestCount = count()
  by profileHash
| order by requestCount desc
```

---

## 13. Complete Event Catalog

This section lists all telemetry events with their IDs, custom dimensions, and measurements.

### Event ID Convention
- **Format**: `TB-{Component}-{Number}`
- **Components**: EXT (Extension), MCP (MCP Server), KQL (Kusto), CACHE, AUTH, CHAT, MIG (Migration)
- **Example**: `TB-EXT-001`, `TB-MCP-001`, `TB-KQL-001`

---

### 13.1 Extension Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-EXT-001** | `Extension.CommandInvoked` | `eventId`, `commandName`, `correlationId`, `sessionId`, `userId`, `version`, `profileHash`, `vsCodeVersion`, `os`, `timestamp` | - |
| **TB-EXT-002** | `Extension.CommandCompleted` | `eventId`, `commandName`, `correlationId`, `sessionId`, `userId`, `success`, `errorType`, `profileHash`, `timestamp` | `durationMs` |
| **TB-EXT-003** | `Extension.McpRequestSent` | `eventId`, `correlationId`, `method`, `sessionId`, `userId`, `profileHash`, `timestamp` | - |
| **TB-EXT-004** | `Extension.McpResponseReceived` | `eventId`, `correlationId`, `method`, `sessionId`, `success`, `statusCode`, `timestamp` | `durationMs` |
| **TB-EXT-005** | `Extension.ProfileSwitched` | `eventId`, `fromProfileHash`, `toProfileHash`, `sessionId`, `userId`, `timestamp` | - |
| **TB-EXT-006** | `Extension.CacheCleared` | `eventId`, `sessionId`, `userId`, `component`, `timestamp` | `itemsCleared`, `bytesFreed` |
| **TB-EXT-007** | `Extension.SetupWizardOpened` | `eventId`, `trigger`, `sessionId`, `userId`, `timestamp` | - |
| **TB-EXT-008** | `Extension.SetupWizardCompleted` | `eventId`, `authFlow`, `hasAppInsights`, `hasKusto`, `sessionId`, `userId`, `timestamp` | `durationMs` |
| **TB-EXT-009** | `Extension.Error` | `eventId`, `errorType`, `operation`, `correlationId`, `commandName`, `stackHash`, `sessionId`, `userId`, `timestamp` | - |

---

### 13.2 MCP Server Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-MCP-001** | `Mcp.ServerStarted` | `eventId`, `sessionId`, `port`, `configSource`, `profileCount`, `version`, `nodeVersion`, `os`, `timestamp` | - |
| **TB-MCP-002** | `Mcp.ConfigurationLoaded` | `eventId`, `source`, `hasMultipleProfiles`, `profileCount`, `validationErrors`, `sessionId`, `timestamp` | - |
| **TB-MCP-005** | `Mcp.Error` | `eventId`, `errorType`, `operation`, `correlationId`, `toolName`, `stackHash`, `sessionId`, `profileHash`, `timestamp` | - |

### 13.2.1 MCP Tool Events (Per Tool)

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-MCP-101** | `Mcp.QueryTelemetry` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `queryName`, `cacheHit`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs`, `resultRowCount` |
| **TB-MCP-102** | `Mcp.GetSavedQueries` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs`, `queryCount` |
| **TB-MCP-103** | `Mcp.SearchQueries` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `searchTerms`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs`, `resultCount` |
| **TB-MCP-104** | `Mcp.SaveQuery` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `queryName`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs` |
| **TB-MCP-105** | `Mcp.GenerateKQL` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `useContext`, `includeExternal`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs` |
| **TB-MCP-106** | `Mcp.GetRecommendations` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs`, `recommendationCount` |
| **TB-MCP-107** | `Mcp.LookupEvent` | `eventId`, `requestId`, `correlationId`, `success`, `errorType`, `caller`, `eventIdLookup`, `profileHash`, `sessionId`, `userId`, `component`, `timestamp` | `durationMs` |

---

### 13.3 Authentication Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-AUTH-001** | `Auth.AuthenticationAttempt` | `eventId`, `authFlow`, `correlationId`, `profileHash`, `sessionId`, `timestamp` | - |
| **TB-AUTH-002** | `Auth.AuthenticationCompleted` | `eventId`, `authFlow`, `success`, `errorType`, `userHash`, `profileHash`, `sessionId`, `timestamp` | `durationMs` |
| **TB-AUTH-003** | `Auth.TokenRefreshed` | `eventId`, `authFlow`, `success`, `profileHash`, `sessionId`, `timestamp` | `durationMs` |
| **TB-AUTH-004** | `Auth.Failed` | `eventId`, `authFlow`, `errorType`, `correlationId`, `profileHash`, `stackHash`, `sessionId`, `timestamp` | `attemptCount` |

---

### 13.4 Kusto Query Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-KQL-001** | `Kusto.QueryExecuted` (Dependency) | `eventId`, `queryName`, `correlationId`, `clusterHash`, `databaseHash`, `cacheHit`, `profileHash`, `component`, `sessionId`, `timestamp` | `durationMs`, `rowCount`, `resultSizeKb` |
| **TB-KQL-002** | `Kusto.QueryFailed` | `eventId`, `queryName`, `errorType`, `correlationId`, `clusterHash`, `databaseHash`, `statusCode`, `profileHash`, `stackHash`, `sessionId`, `timestamp` | `attemptCount`, `durationMs` |
| **TB-KQL-003** | `Kusto.QueryCached` | `eventId`, `queryName`, `cacheAge`, `profileHash`, `sessionId`, `timestamp` | `cacheSizeKb` |
| **TB-KQL-004** | `Kusto.CacheMiss` | `eventId`, `queryName`, `reason`, `profileHash`, `sessionId`, `timestamp` | - |

---

### 13.5 Cache Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-CACHE-001** | `Cache.Hit` | `eventId`, `cacheKey`, `component`, `sessionId`, `timestamp` | `ageSeconds`, `sizeKb` |
| **TB-CACHE-002** | `Cache.Miss` | `eventId`, `cacheKey`, `reason`, `component`, `sessionId`, `timestamp` | - |
| **TB-CACHE-003** | `Cache.Set` | `eventId`, `cacheKey`, `component`, `sessionId`, `timestamp` | `ttlSeconds`, `sizeKb` |
| **TB-CACHE-004** | `Cache.Cleared` | `eventId`, `component`, `sessionId`, `userId`, `trigger`, `timestamp` | `itemCount`, `totalSizeKb` |
| **TB-CACHE-005** | `Cache.Expired` | `eventId`, `cacheKey`, `component`, `sessionId`, `timestamp` | `ageSeconds` |

---

### 13.6 Chat Participant Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-CHAT-001** | `Chat.MessageReceived` | `eventId`, `correlationId`, `sessionId`, `userId`, `profileHash`, `chatMode`, `timestamp` | `messageLength` |
| **TB-CHAT-002** | `Chat.ResponseSent` | `eventId`, `correlationId`, `sessionId`, `toolsUsed`, `success`, `errorType`, `timestamp` | `durationMs`, `tokenCount` |
| **TB-CHAT-003** | `Chat.ToolRecommended` | `eventId`, `toolName`, `correlationId`, `sessionId`, `timestamp` | - |
| **TB-CHAT-004** | `Chat.QueryGenerated` | `eventId`, `correlationId`, `queryType`, `sessionId`, `hasExternalRefs`, `timestamp` | `generationTimeMs` |

---

### 13.7 Migration Events

| Event ID | Event Name | Custom Dimensions | Measurements |
|----------|-----------|-------------------|--------------|
| **TB-MIG-001** | `Migration.Started` | `eventId`, `fromVersion`, `toVersion`, `hasLegacySettings`, `sessionId`, `userId`, `timestamp` | - |
| **TB-MIG-002** | `Migration.Completed` | `eventId`, `fromVersion`, `toVersion`, `success`, `settingsMigrated`, `profilesCreated`, `sessionId`, `userId`, `timestamp` | `durationMs` |
| **TB-MIG-003** | `Migration.Failed` | `eventId`, `fromVersion`, `toVersion`, `errorType`, `step`, `stackHash`, `sessionId`, `userId`, `timestamp` | - |

---

### 13.8 Common Dimensions Reference

All events should include these **standard dimensions**:

| Dimension | Type | Description | Example |
|-----------|------|-------------|---------|
| `eventId` | string | Event identifier (TB-XXX-NNN) | `TB-EXT-001` |
| `timestamp` | string | ISO 8601 timestamp | `2025-11-20T14:30:00.000Z` |
| `sessionId` | string | Session GUID (per process) | `a1b2c3d4-e5f6-...` |
| `userId` | string | Hashed user identifier | `f4e3d2c1b0a9...` |
| `correlationId` | string | Request correlation GUID | `x1y2z3a4-b5c6-...` |
| `version` | string | Extension/MCP version | `1.0.5` |
| `component` | string | Component name | `extension`, `mcp`, `shared` |
| `profileHash` | string | Hashed profile name | `a1b2c3d4e5f6` |

**Optional dimensions** (context-specific):
| Dimension | Type | Description |
|-----------|------|-------------|
| `success` | boolean | Operation success flag |
| `errorType` | string | Error class name |
| `stackHash` | string | Hashed stack trace (first 5 frames) |
| `os` | string | Operating system |
| `vsCodeVersion` | string | VS Code version |
| `nodeVersion` | string | Node.js version |

---

### 13.9 Sampling Configuration by Event

```json
{
  "telemetry": {
    "samplingRules": {
      "TB-EXT-001": 100,  // Command invoked - always track
      "TB-EXT-002": 100,  // Command completed - always track
      "TB-EXT-009": 100,  // Extension errors - always track
      "TB-MCP-005": 100,  // MCP errors - always track
      "TB-MCP-101": 100,  // QueryTelemetry - always track
      "TB-MCP-102": 100,  // GetSavedQueries - always track
      "TB-MCP-103": 100,  // SearchQueries - always track
      "TB-MCP-104": 100,  // SaveQuery - always track
      "TB-MCP-105": 100,  // GenerateKQL - always track
      "TB-MCP-106": 100,  // GetRecommendations - always track
      "TB-MCP-107": 100,  // LookupEvent - always track
      "TB-KQL-001": 25,   // Kusto query (success) - 25% sample
      "TB-KQL-002": 100,  // Kusto query failed - always track
      "TB-KQL-003": 10,   // Query cached - 10% sample (high volume)
      "TB-AUTH-001": 100, // Auth attempt - always track
      "TB-AUTH-002": 100, // Auth completed - always track
      "TB-AUTH-004": 100, // Auth failed - always track
      "TB-CACHE-001": 5,  // Cache hit - 5% sample (very high volume)
      "TB-CACHE-002": 25, // Cache miss - 25% sample
      "TB-CACHE-004": 100, // Cache cleared - always track
      "TB-CHAT-001": 50,  // Chat message - 50% sample
      "TB-CHAT-002": 50,  // Chat response - 50% sample
      "TB-MIG-001": 100,  // Migration - always track
      "TB-MIG-002": 100,  // Migration - always track
      "TB-MIG-003": 100   // Migration - always track
    }
  }
}
```

---

### 13.10 Usage Example

**Extension Command Handler:**
```typescript
const correlationId = generateGuid();
const startTime = Date.now();

telemetry.trackEvent('Extension.CommandInvoked', {
  eventId: 'TB-EXT-001',
  commandName: 'runQuery',
  correlationId,
  sessionId: this.sessionId,
  userId: this.userId,
  version: this.extensionVersion,
  profileHash: hashValue(this.currentProfile),
  vsCodeVersion: vscode.version,
  os: process.platform,
  timestamp: new Date().toISOString()
});

try {
  // Execute command...
  const result = await this.executeCommand();
  
  telemetry.trackEvent('Extension.CommandCompleted', {
    eventId: 'TB-EXT-002',
    commandName: 'runQuery',
    correlationId,
    sessionId: this.sessionId,
    userId: this.userId,
    success: 'true',
    profileHash: hashValue(this.currentProfile),
    timestamp: new Date().toISOString()
  }, {
    durationMs: Date.now() - startTime
  });
} catch (error) {
  telemetry.trackException(error, {
    eventId: 'TB-EXT-009',
    errorType: error.name,
    operation: 'runQuery',
    correlationId,
    commandName: 'runQuery',
    stackHash: hashStack(error.stack),
    sessionId: this.sessionId,
    userId: this.userId,
    timestamp: new Date().toISOString()
  });
}
```

**MCP Tool Handler (QueryTelemetry example):**
```typescript
const requestId = generateGuid();
const correlationId = req.body.params?._correlationId || generateGuid();
const startTime = Date.now();

try {
  // Execute the tool logic...
  const result = await this.executeQueryTelemetry(params);
  
  telemetry.trackEvent('Mcp.QueryTelemetry', {
    eventId: 'TB-MCP-101',
    requestId,
    correlationId,
    success: 'true',
    caller: params.caller || 'extension',
    queryName: getQueryName(params.kql),
    cacheHit: result.cached.toString(),
    profileHash: hashValue(this.currentProfile),
    sessionId: this.sessionId,
    userId: this.userId,
    component: 'mcp',
    timestamp: new Date().toISOString()
  }, {
    durationMs: Date.now() - startTime,
    resultRowCount: result.rows?.length || 0
  });
  
  return result;
} catch (error) {
  telemetry.trackEvent('Mcp.QueryTelemetry', {
    eventId: 'TB-MCP-101',
    requestId,
    correlationId,
    success: 'false',
    errorType: error.name,
    caller: params.caller || 'extension',
    profileHash: hashValue(this.currentProfile),
    sessionId: this.sessionId,
    userId: this.userId,
    component: 'mcp',
    timestamp: new Date().toISOString()
  }, {
    durationMs: Date.now() - startTime
  });
  
  telemetry.trackException(error, {
    eventId: 'TB-MCP-005',
    errorType: error.name,
    operation: 'QueryTelemetry',
    correlationId,
    toolName: 'query_telemetry',
    stackHash: hashStack(error.stack),
    sessionId: this.sessionId,
    profileHash: hashValue(this.currentProfile),
    timestamp: new Date().toISOString()
  });
  
  throw error;
}
```

**MCP Kusto Dependency (within tool execution):**
```typescript
const startTime = Date.now();

try {
  const result = await kustoClient.execute(kql, token);
  
  // Hash cluster/database for privacy
  const clusterHash = hashValue(cluster).substring(0, 8);
  const databaseHash = hashValue(database).substring(0, 8);
  
  telemetry.trackDependency(
    'Kusto',
    `${clusterHash}/${databaseHash}`,
    Date.now() - startTime,
    true,
    '200',
    {
      eventId: 'TB-KQL-001',
      queryName: 'ErrorsByDay',
      correlationId,
      clusterHash,
      databaseHash,
      cacheHit: 'false',
      profileHash: hashValue(profileName),
      component: 'mcp',
      sessionId: this.sessionId,
      timestamp: new Date().toISOString()
    }
  );
} catch (error) {
  const clusterHash = hashValue(cluster).substring(0, 8);
  const databaseHash = hashValue(database).substring(0, 8);
  
  telemetry.trackEvent('Kusto.QueryFailed', {
    eventId: 'TB-KQL-002',
    queryName: 'ErrorsByDay',
    errorType: error.name,
    correlationId,
    clusterHash,
    databaseHash,
    statusCode: error.statusCode || '500',
    profileHash: hashValue(profileName),
    stackHash: hashStack(error.stack),
    sessionId: this.sessionId,
    timestamp: new Date().toISOString()
  }, {
    attemptCount: 1,
    durationMs: Date.now() - startTime
  });
}
```

---

## 14. Implementation Checklist

**Shared Package**
- [ ] Create `shared/src/usageTelemetry.ts` with `IUsageTelemetry` interface
- [ ] Implement `NoOpUsageTelemetry` (when disabled or connection string missing)
- [ ] Add telemetry config to `shared/src/config.ts` (global + per-profile, excluding connection string)
- [ ] Add utility functions: `generateGuid()`, `hashValue()`, `trackExceptionSafe()`
- [ ] Create `shared/src/telemetryConfig.generated.ts` template (gitignored) for CI injection

**Extension**
- [ ] Install `@vscode/extension-telemetry` package
- [ ] Implement `VSCodeUsageTelemetry` wrapper around `TelemetryReporter`
- [ ] Initialize in `activate()`, check `vscode.env.isTelemetryEnabled` and connection string presence
- [ ] Import `TELEMETRY_CONNECTION_STRING` from generated file, fall back to `NoOpUsageTelemetry` if missing
- [ ] Wrap all telemetry initialization and calls in try/catch (never fail commands)
- [ ] Wrap command handlers with correlation ID and telemetry
- [ ] Add error telemetry in key services (`mcpClient`, `migrationService`)
- [ ] Pass `correlationId` to MCP requests
- [ ] Add common properties: `sessionId`, `userId` (hashed), `version`, `os`

**MCP Backend**
- [ ] Install `applicationinsights` package
- [ ] Implement `AppInsightsUsageTelemetry` using AI SDK
- [ ] Add telemetry config reading from `.bctb-config.json` (enabled, environment, sampling only)
- [ ] Import `TELEMETRY_CONNECTION_STRING` from generated file, fall back to `NoOpUsageTelemetry` if missing
- [ ] Wrap all telemetry initialization and calls in try/catch (never fail MCP operations)
- [ ] Initialize in server startup with connection string
- [ ] Create Express middleware for request correlation
- [ ] Wrap MCP tool handlers with telemetry (invoked/completed)
- [ ] Use `trackDependency` for Kusto calls in `shared/src/kusto.ts`
- [ ] Add error telemetry with stack hashing
- [ ] Implement sampling logic (per event type)
- [ ] Add common properties: `sessionId`, `userId`, `profileHash`

**Configuration & CI**
- [ ] Update `.bctb-config.json` schema with `telemetry` section (enabled, environment, sampling - NO connection string)
- [ ] Support per-profile overrides (for sampling, environment tagging)
- [ ] Add `AI_CONNECTION_STRING` to CI secrets (GitHub Actions / Azure DevOps)
- [ ] Update CI build workflow to inject connection string into generated file before compilation
- [ ] Add `shared/src/telemetryConfig.generated.ts` to `.gitignore`
- [ ] Create separate dev/prod AI resources (dev for local testing, prod for releases)
- [ ] Document local dev setup with `.env` file for `AI_CONNECTION_STRING`

**Docs & Tests**
- [ ] Update `docs/UserGuide.md` with telemetry section (what's collected, privacy, how to disable)
- [ ] Document sampling strategy and cost estimates
- [ ] Add unit tests using mock `IUsageTelemetry` implementation
- [ ] Test correlation flow: Extension → MCP → Kusto
- [ ] Validate telemetry end‑to‑end in a dev AI resource
- [ ] Create example analysis queries in Application Insights
